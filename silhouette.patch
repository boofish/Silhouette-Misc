diff --git a/clang/lib/Driver/ToolChains/BareMetal.cpp b/clang/lib/Driver/ToolChains/BareMetal.cpp
index 1544727050f..9d0ee062c55 100644
--- a/clang/lib/Driver/ToolChains/BareMetal.cpp
+++ b/clang/lib/Driver/ToolChains/BareMetal.cpp
@@ -156,8 +156,10 @@ void BareMetal::AddCXXStdlibLibArgs(const ArgList &Args,
 
 void BareMetal::AddLinkRuntimeLib(const ArgList &Args,
                                   ArgStringList &CmdArgs) const {
+#if 0
   CmdArgs.push_back(Args.MakeArgString("-lclang_rt.builtins-" +
                                        getTriple().getArchName() + ".a"));
+#endif
 }
 
 void baremetal::Linker::ConstructJob(Compilation &C, const JobAction &JA,
diff --git a/llvm/include/llvm/CodeGen/MachineInstr.h b/llvm/include/llvm/CodeGen/MachineInstr.h
index fa532ec831f..b2cc8421676 100644
--- a/llvm/include/llvm/CodeGen/MachineInstr.h
+++ b/llvm/include/llvm/CodeGen/MachineInstr.h
@@ -107,6 +107,8 @@ public:
                                         // known to be exact.
     FPExcept     = 1 << 14,             // Instruction may raise floating-point
                                         // exceptions.
+    ShadowStack  = 1 << 15,             // Silhouette: Instruction is part of
+                                        // shadow stack
   };
 
 private:
diff --git a/llvm/lib/Target/ARM/ARMInstrThumb2.td b/llvm/lib/Target/ARM/ARMInstrThumb2.td
index 7cbfaba7a8e..20eb1e74a3d 100644
--- a/llvm/lib/Target/ARM/ARMInstrThumb2.td
+++ b/llvm/lib/Target/ARM/ARMInstrThumb2.td
@@ -1684,7 +1684,7 @@ def t2STRH_preidx: t2PseudoInst<(outs GPRnopc:$Rn_wb),
 // only.
 // Ref: A8.6.193 STR (immediate, Thumb) Encoding T4
 class T2IstT<bits<2> type, string opc, InstrItinClass ii>
-  : T2Ii8<(outs rGPR:$Rt), (ins t2addrmode_imm8:$addr), ii, opc,
+  : T2Ii8<(outs), (ins rGPR:$Rt, t2addrmode_imm8:$addr), ii, opc,
           "\t$Rt, $addr", []>, Sched<[WriteST]> {
   let Inst{31-27} = 0b11111;
   let Inst{26-25} = 0b00;
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteConvertFuncList.h b/llvm/lib/Target/ARM/ARMSilhouetteConvertFuncList.h
new file mode 100644
index 00000000000..dd6ff71b558
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteConvertFuncList.h
@@ -0,0 +1,184 @@
+//===-- ARMSilhouetteSTR2STRT - Store to Unprivileged Store convertion-----===//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+// This file contains a list of functions on which our pass runs, and 
+// a list of functions on which our pass does not run. It servers two purposes.
+// One is to help debugging. The other is to really ignore certain functions:
+// some function are supposed to be running in privileged mode. We need to find 
+// out which those functions are.
+// 
+//===----------------------------------------------------------------------===//
+//
+
+#include <set>
+
+// A whitelist of functions on which this pass will run. This is a helper for
+// development. Will take it out after the development is done.
+const static std::set<std::string> funcWhitelist = {
+  // main and HAL lib functions without using timer
+#if 0
+  "main",
+  "HAL_IncTick",
+  "HAL_GPIO_Init",
+  "HAL_RCC_GetSysClockFreq",
+  "HAL_TIM_IRQHandler",
+  "HAL_TIM_IC_CaptureCallback",
+  "HAL_TIM_OC_DelayElapsedCallback",
+  "HAL_TIM_PWM_PulseFinishedCallback",
+  "HAL_TIM_TriggerCallback",
+  "HAL_TIMEx_CommutationCallback",
+  "HAL_TIMEx_BreakCallback",
+  "HAL_TIMEx_Break2Callback",
+  "HAL_TIM_PeriodElapsedCallback"
+  "HAL_UART_Init",
+  "HAL_UART_MspInit",
+  "UART_SetConfig",
+  "UART_AdvFeatureConfig",
+  "UART_CheckIdleState",
+  "HAL_UART_Transmit",
+  "vListInsertEnd",
+  "UART_WaitOnFlagUntilTimeout",
+  "uxListRemove",
+  "prvResetNextTaskUnblockTime",
+  "vTaskSwitchContext",
+  "xTaskIncrementTick",
+  "xTaskGetSchedulerState",
+  "PendSV_Handler",
+  "xPortSysTickHandler",
+  "BSP_COM_Init",
+  "vMainUARTPrintString",
+  "Console_UART_Init",
+  "CopyDataInit", // this one only has a STR(register)
+  "LoopCopyDataInit", // no store
+  "FillZerobss",  // str.w,
+  "__register_exitproc"
+#endif
+
+  // BEEBS benchmark
+#if 1
+  // "main",
+  "initialise_benchmark",
+  // "benchmark",
+  "verify_benchmark",
+  // aha-compress
+  "compress3",
+  "compress4",
+  // cnt
+  "Test",
+  "Initialize",
+  "InitSeed",
+  "Sum",
+  "RandomInteger",
+
+  // dtoi
+  "strtod",
+  // dijkstra
+  "enqueue",
+  "dequeue",
+  "qcount",
+  "dijkstra",
+  // ndes
+  "des",
+  "ks",
+  "cyfun",
+  "foo",
+  "foo2",
+  "bar",
+#endif
+};
+
+// A blacklist of functions on which this pass will ignore. 
+const static std::set<std::string> funcBlacklist {
+  // This function (instrumented) causes the program to enter an infinite loop.
+  // I guesss the reason is that some store(s) in this function are supposed to 
+  // be privileged stores.
+  "SystemInit",  
+
+  // timer related functions
+  // Instrumenting them would also break programs.
+  "HAL_Init",
+    "HAL_NVIC_SetPriorityGrouping",  // called by HAL_Init
+    "NVIC_SetPriorityGrouping",      // called by HAL_NVIC_SetPriorityGrouping
+    "HAL_InitTick",                  // called by HAL_Init
+      "HAL_NVIC_SetPriority",        // called by HAL_InitTick
+        "NVIC_GetPriorityGrouping",  // called by HAL_NVIC_SetPriority
+        "NVIC_EncodePriority",       // called by HAL_NVIC_SetPriority
+        "NVIC_SetPriority",          // called by HAL_NVIC_SetPriority
+      "HAL_NVIC_EnableIRQ",          // called by HAL_InitTick
+        "NVIC_EnableIRQ",            // called by HAL_NVIC_EnableIRQ
+      "HAL_RCC_GetClockConfig",      // called by HAL_InitTick
+      "HAL_RCC_GetPCLK1Freq",        // called by HAL_InitTick
+        "HAL_RCC_GetHCLKFreq",       // called by HAL_RCC_GetPCLK1Freq
+      "HAL_TIM_Base_Init",           // called by HAL_InitTick
+        "HAL_TIM_Base_MspInit",      // called by HAL_TIM_Base_Init
+        "TIM_Base_SetConfig",        // called by HAL_TIM_Base_Init
+      "HAL_TIM_Base_Start_IT",       // called by HAL_InitTick
+    "HAL_MspInit",                   // called by HAL_Init
+    "TIM_SlaveTimer_SetConfig",      // called by HAL_TIM_SlaveConfigSynchronization
+    "RCCEx_GetSAIxPeriphCLKFreq",
+    "initMPU",
+    "HAL_GPIO_Init",
+    // "BSP_COM_Init",
+    "HAL_UART_Transmit",
+    "HAL_RCC_OscConfig",
+    "HAL_RCC_ClockConfig",
+    "HAL_PWREx_ControlVoltageScaling",
+    //     
+    "HAL_TIM_IRQHandler",            // Timer interrupt handler
+    "SysTick_Handler",               // Timer related handler
+    "UART_CheckIdleState",           // Timer related function
+    "UART_AdvFeatureConfig",         // Timer related function
+    "UART_SetConfig",                // Timer related function
+    "TIM6_DAC_IRQHandler",           // Calls HAL_TIM_IRQHandler
+    "BSP_COM_Init",                  // Calls HAL_UART_Init
+    "HAL_UART_Init",                 // Calls UART_SetConfig
+    "HAL_RCC_GetSysClockFreq",       // Called by UART_SetConfig
+    "HAL_RCC_GetPCLK1Freq",          // Called by UART_SetConfig
+    "HAL_RCC_GetPCLK2Freq",          // Called by UART_SetConfig
+    "HAL_SYSTICK_IRQHandler",
+    "HAL_SYSTICK_Callback",
+    // Other HAL control functions
+    "HAL_IncTick",
+    "HAL_GetTick",
+    "HAL_Delay",
+    "HAL_SuspendTick",
+    "HAL_ResumeTick",
+    "HAL_GetHalVersion",
+    "HAL_GetREVID",
+    "HAL_GetDEVID",
+    // Other HAL init/de-init functions
+    "HAL_DeInit",
+    "HAL_MspDeInit",
+    // Other HAL Time Base functions
+    "HAL_TIM_Base_DeInit",
+    "HAL_TIM_Base_MspDeInit",
+    "HAL_TIM_Base_MspDeInit",
+    "HAL_TIM_Base_Start",
+    "HAL_TIM_Base_Stop",
+    // "HAL_TIM+Base_Start_IT", // Added already above
+    "HAL_TIM_Base_Stop_IT",
+    "HAL_TIM_Base_Start_DMA",
+    "HAL_TIM_Base_Stop_DMA",
+    // HAL Time Callback functions
+    "HAL_TIM_PeriodElapsedCallback",
+    "HAL_TIM_OC_DelayElapsedCallback",
+    "HAL_TIM_IC_CaptureCallback",
+    "HAL_TIM_PWM_PulseFinishedCallback",
+    "HAL_TIM_TriggerCallback",
+    "HAL_TIM_ErrorCallback",
+    // HAL TIMEx Callbacks
+    "HAL_TIMEx_CommutationCallback",
+    "HAL_TIMEx_BreakCallback",
+    "HAL_TIMEx_Break2Callback",
+
+    // Functions used by the F469 board
+    "BSP_SDRAM_Init",
+    "HAL_DMA_Init",
+    "SystemClock_Config",
+    "MPU_Init",
+};
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteInstrumentor.cpp b/llvm/lib/Target/ARM/ARMSilhouetteInstrumentor.cpp
new file mode 100644
index 00000000000..0eb5b1d8aba
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteInstrumentor.cpp
@@ -0,0 +1,434 @@
+//===- ARMSilhouetteInstrumentor - A helper class for instrumentation -----===//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This class implements methods that can help passes of its subclass easily
+// instrument machine IR without concerns of breaking IT blocks.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#include "ARM.h"
+#include "ARMBaseInstrInfo.h"
+#include "ARMSilhouetteInstrumentor.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include <deque>
+
+using namespace llvm;
+
+static DebugLoc DL;
+
+//
+// Method: getITBlockSize()
+//
+// Description:
+//   This method computes how many predicated instructions an IT instruction
+//   covers.
+//
+// Input:
+//   IT - A reference to an IT instruction.
+//
+// Return value:
+//   The number of predicated instructions IT covers.
+//
+unsigned
+ARMSilhouetteInstrumentor::getITBlockSize(const MachineInstr & IT) {
+  assert(IT.getOpcode() == ARM::t2IT && "Not an IT instruction!");
+
+  unsigned Mask = IT.getOperand(1).getImm() & 0xf;
+  assert(Mask != 0 && "Invalid IT mask!");
+
+  if (Mask & 0x1) {
+    return 4;
+  } else if (Mask & 0x2) {
+    return 3;
+  } else if (Mask & 0x4) {
+    return 2;
+  } else {
+    return 1;
+  }
+}
+
+//
+// Method: findIT()
+//
+// Description:
+//   This method finds the IT instruction that forms an IT block containing a
+//   given instruction MI.  It also computes the distance (from 1 to 4) between
+//   the IT and MI.  If there is no such IT, a null pointer is returned.
+//
+// Inputs:
+//   MI       - A reference to an instruction from which to find IT.
+//   distance - A reference to an unsigned to store the distance.
+//
+// Return value:
+//   A pointer to IT if found, nullptr otherwise.
+//
+MachineInstr *
+ARMSilhouetteInstrumentor::findIT(MachineInstr & MI, unsigned & distance) {
+  assert(MI.getOpcode() != ARM::t2IT && "MI cannot be IT!");
+
+  MachineInstr * Prev = &MI;
+  unsigned dist = 0;
+  while (Prev != nullptr && dist < 5 && Prev->getOpcode() != ARM::t2IT) {
+    Prev = Prev->getPrevNode();
+    ++dist;
+  }
+  if (Prev != nullptr && dist < 5 && Prev->getOpcode() == ARM::t2IT) {
+    if (getITBlockSize(*Prev) >= dist) {
+      distance = dist;
+      return Prev;
+    }
+  }
+  return nullptr;
+}
+
+//
+// Method: findIT()
+//
+// Description:
+//   This method finds the IT instruction that forms an IT block containing a
+//   given instruction MI.  It also computes the distance (from 1 to 4) between
+//   the IT and MI.  If there is no such IT, a null pointer is returned.
+//
+// Inputs:
+//   MI       - A const reference to an instruction from which to find IT.
+//   distance - A reference to an unsigned to store the distance.
+//
+// Return value:
+//   A const pointer to IT if found, nullptr otherwise.
+//
+const MachineInstr *
+ARMSilhouetteInstrumentor::findIT(const MachineInstr & MI, unsigned & distance) {
+  return findIT(const_cast<MachineInstr &>(MI), distance);
+}
+
+//
+// Method: insertInstBefore()
+//
+// Description:
+//   This method inserts an instruction Inst before a given instruction MI.  If
+//   MI is a predicated instruction within an IT block, then Inst will have the
+//   same predicate as MI and also end up in an IT block.  Note that MI cannot
+//   be an IT instruction itself.
+//
+// Inputs:
+//   MI   - A reference to an instruction before which to insert Inst.
+//   Inst - A pointer to an instruction to insert.
+//
+void
+ARMSilhouetteInstrumentor::insertInstBefore(MachineInstr & MI,
+                                            MachineInstr * Inst) {
+  std::deque<MachineInstr *> Insts { Inst };
+  insertInstsBefore(MI, Insts);
+}
+
+//
+// Method: insertInstAfter()
+//
+// Description:
+//   This method inserts an instruction Inst after a given instruction MI.  If
+//   MI is a predicated instruction within an IT block, then Inst will have the
+//   same predicate as MI and also end up in an IT block.  Note that MI cannot
+//   be an IT instruction itself.
+//
+// Inputs:
+//   MI   - A reference to an instruction after which to insert Inst.
+//   Inst - A pointer to an instruction to insert.
+//
+void
+ARMSilhouetteInstrumentor::insertInstAfter(MachineInstr & MI,
+                                           MachineInstr * Inst) {
+  std::deque<MachineInstr *> Insts { Inst };
+  insertInstsAfter(MI, Insts);
+}
+
+//
+// Method: insertInstsBefore()
+//
+// Description:
+//   This method inserts a group of instructions contained in a deque before a
+//   given instruction MI.  If MI is a predicated instruction within an IT
+//   block, then the new instructions will have the same predicate as MI and
+//   also end up in one or more IT blocks.  Note that MI cannot be an IT
+//   instruction itself.
+//
+// Inputs:
+//   MI    - A reference to an instruction before which to insert instructions.
+//   Insts - A reference to a deque containing the instructions.
+//
+void
+ARMSilhouetteInstrumentor::insertInstsBefore(MachineInstr & MI,
+                                             std::deque<MachineInstr *> & Insts) {
+  MachineFunction & MF = *MI.getMF();
+  MachineBasicBlock & MBB = *MI.getParent();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  unsigned distance;
+  MachineInstr * IT = findIT(MI, distance);
+
+  // Do insert new instructions before MI
+  for (MachineInstr * Inst : Insts) {
+    MBB.insert(MI, Inst);
+  }
+
+  // If MI is inside an IT block, we should make sure to cover all new
+  // instructions with IT(s)
+  if (IT != nullptr) {
+    unsigned ITBlockSize = getITBlockSize(*IT);
+    unsigned Mask = IT->getOperand(1).getImm() & 0xf;
+    ARMCC::CondCodes firstCond = (ARMCC::CondCodes)IT->getOperand(0).getImm();
+    std::deque<bool> DQMask = decodeITMask(Mask);
+    bool sameAsFirstCond = DQMask[distance - 1];
+
+    // Find the range of instructions that are supposed to be in IT block(s)
+    MachineBasicBlock::iterator firstMI(IT->getNextNode()); // Inclusive
+    MachineBasicBlock::iterator lastMI(MI);                 // Non-inclusive
+    for (unsigned i = distance; i <= ITBlockSize; ++i) {
+      ++lastMI;
+    }
+
+    // Track new instructions in DQMask
+    auto it = DQMask.begin();
+    for (unsigned i = 0; i < distance - 1; ++i) {
+      it++;
+    }
+    DQMask.insert(it, Insts.size(), sameAsFirstCond);
+
+    // Insert ITs to cover instructions from [firstMI, lastMI)
+    for (MachineBasicBlock::iterator i(firstMI); i != lastMI; ) {
+      std::deque<bool> NewDQMask;
+      MachineBasicBlock::iterator j(i);
+      for (unsigned k = 0; k < 4 && j != lastMI; ++j, ++k) {
+        NewDQMask.push_back(DQMask.front());
+        DQMask.pop_front();
+      }
+      bool flip = false;
+      if (!NewDQMask[0]) {
+        for (unsigned k = 0; k < NewDQMask.size(); ++k) {
+          NewDQMask[k] = !NewDQMask[k];
+        }
+        flip = true;
+      }
+      BuildMI(MBB, i, DL, TII->get(ARM::t2IT))
+      .addImm(flip ? ARMCC::getOppositeCondition(firstCond) : firstCond)
+      .addImm(encodeITMask(NewDQMask));
+      i = j; // Update i here
+    }
+
+    // Remove the original IT
+    IT->eraseFromParent();
+  }
+}
+
+//
+// Method: insertInstsAfter()
+//
+// Description:
+//   This method inserts a group of instructions contained in a deque after a
+//   given instruction MI.  If MI is a predicated instruction within an IT
+//   block, then the new instructions will have the same predicate as MI and
+//   also end up in one or more IT blocks.  Note that MI cannot be an IT
+//   instruction itself.
+//
+// Inputs:
+//   MI    - A reference to an instruction after which to insert instructions.
+//   Insts - A reference to a deque containing the instructions.
+//
+void
+ARMSilhouetteInstrumentor::insertInstsAfter(MachineInstr & MI,
+                                            std::deque<MachineInstr *> & Insts) {
+  MachineFunction & MF = *MI.getMF();
+  MachineBasicBlock & MBB = *MI.getParent();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+  MachineBasicBlock::iterator NextMI(MI); ++NextMI;
+
+  unsigned distance;
+  MachineInstr * IT = findIT(MI, distance);
+
+  // Do insert new instructions after MI
+  for (MachineInstr * Inst : Insts) {
+    MBB.insert(NextMI, Inst);
+  }
+
+  // If MI is inside an IT block, we should make sure to cover all new
+  // instructions with IT(s)
+  if (IT != nullptr) {
+    unsigned ITBlockSize = getITBlockSize(*IT);
+    unsigned Mask = IT->getOperand(1).getImm() & 0xf;
+    ARMCC::CondCodes firstCond = (ARMCC::CondCodes)IT->getOperand(0).getImm();
+    std::deque<bool> DQMask = decodeITMask(Mask);
+    bool sameAsFirstCond = DQMask[distance - 1];
+
+    // Find the range of instructions that are supposed to be in IT block(s)
+    MachineBasicBlock::iterator firstMI(IT->getNextNode()); // Inclusive
+    MachineBasicBlock::iterator lastMI(Insts.back());       // Non-inclusive
+    for (unsigned i = distance; i <= ITBlockSize; ++i) {
+      ++lastMI;
+    }
+
+    // Track new instructions in DQMask
+    auto it = DQMask.begin();
+    for (unsigned i = 0; i <= distance - 1; ++i) {
+      it++;
+    }
+    DQMask.insert(it, Insts.size(), sameAsFirstCond);
+
+    // Insert ITs to cover instructions from [firstMI, lastMI)
+    for (MachineBasicBlock::iterator i(firstMI); i != lastMI; ) {
+      std::deque<bool> NewDQMask;
+      MachineBasicBlock::iterator j(i);
+      for (unsigned k = 0; k < 4 && j != lastMI; ++j, ++k) {
+        NewDQMask.push_back(DQMask.front());
+        DQMask.pop_front();
+      }
+      bool flip = false;
+      if (!NewDQMask[0]) {
+        for (unsigned k = 0; k < NewDQMask.size(); ++k) {
+          NewDQMask[k] = !NewDQMask[k];
+        }
+        flip = true;
+      }
+      BuildMI(MBB, i, DL, TII->get(ARM::t2IT))
+      .addImm(flip ? ARMCC::getOppositeCondition(firstCond) : firstCond)
+      .addImm(encodeITMask(NewDQMask));
+      i = j; // Update i here
+    }
+
+    // Remove the original IT
+    IT->eraseFromParent();
+  }
+}
+
+//
+// Method: removeInst()
+//
+// Description:
+//   This method removes a given instruction MI from machine IR.  If MI is a
+//   predicated instruction within an IT block, then its corresponding IT
+//   instruction will be updated or removed as well.  Note that MI cannot be an
+//   IT instruction itself.
+//
+// Input:
+//   MI - A reference to the instruction to remove.
+//
+void
+ARMSilhouetteInstrumentor::removeInst(MachineInstr & MI) {
+  unsigned distance;
+  MachineInstr * IT = findIT(MI, distance);
+
+  // If MI was inside an IT block, we should make sure to update/remove the IT
+  // instruction
+  if (IT != nullptr) {
+    unsigned Mask = IT->getOperand(1).getImm() & 0xf;
+    ARMCC::CondCodes firstCond = (ARMCC::CondCodes)IT->getOperand(0).getImm();
+    std::deque<bool> DQMask = decodeITMask(Mask);
+
+    // Remove MI's entry from DQMask
+    auto it = DQMask.begin();
+    for (unsigned i = 0; i < distance - 1; ++i) {
+      it++;
+    }
+    DQMask.erase(it);
+
+    // Remove IT as well if MI was the only instruction in the IT block
+    if (DQMask.empty()) {
+      IT->eraseFromParent();
+    } else {
+      // If MI was the first instruction in the IT block, removing MI might
+      // change the first condition, in which case we need to flip it
+      if (!DQMask[0]) {
+        for (unsigned i = 0; i < DQMask.size(); ++i) {
+          DQMask[i] = !DQMask[i];
+        }
+        IT->getOperand(0).setImm(ARMCC::getOppositeCondition(firstCond));
+      }
+      // Update the IT mask
+      IT->getOperand(1).setImm(encodeITMask(DQMask));
+    }
+  }
+
+  // Now do remove MI
+  MI.eraseFromParent();
+}
+
+//
+// Method: decodeITMask()
+//
+// Description:
+//   This method decodes an IT mask in LLVM's representation and puts a list of
+//   boolean values in a deque to return.  The boolean values represent whether
+//   their corresponding instructions in an IT block have the same predicate as
+//   the first one (which indicates that the first boolean value is always
+//   true).
+//
+// Input:
+//   Mask - The IT mask in LLVM's representation (immediate value of the second
+//          operand of a t2IT instruction).
+//
+// Return value:
+//   A deque of boolean values (see the above description).
+//
+std::deque<bool>
+ARMSilhouetteInstrumentor::decodeITMask(unsigned Mask) {
+  Mask &= 0xf;
+  assert(Mask != 0 && "Invalid IT mask!");
+
+  std::deque<bool> DQMask { true };
+  unsigned size = 4;
+  for (unsigned i = 0x1; i < 0x10; i <<= 1) {
+    if (Mask & i) {
+      break;
+    }
+    --size;
+  }
+  for (unsigned i = 3; i > 4 - size; --i) {
+    DQMask.push_back((Mask & (1 << i)) == 0);
+  }
+
+  return DQMask;
+}
+
+//
+// Method: encodeITMask()
+//
+// Description:
+//   This method takes an IT mask in the form of a list of boolean values and
+//   encodes it into LLVM's representation.  The boolean values represent
+//   whether their corresponding instructions in an IT block have the same
+//   predicate as the first one (which requires that the first boolean value
+//   be always true).
+//
+// Input:
+//   DQMask - An IT mask in the form of a list of boolean values.
+//
+// Return value:
+//   The IT mask in LLVM's representation (immediate value of the second
+//   operand of a t2IT instruction).
+//
+unsigned
+ARMSilhouetteInstrumentor::encodeITMask(std::deque<bool> DQMask) {
+  assert(!DQMask.empty() && "Invalid deque representation of an IT mask!");
+  assert(DQMask.size() <= 4 && "Invalid deque representation of an IT mask!");
+  assert(DQMask[0] && "Invalid deque representation of an IT mask!");
+
+  unsigned Mask = 0;
+  for (unsigned i = 1; i < DQMask.size(); ++i) {
+    Mask |= DQMask[i] ? 0 : 1;
+    Mask <<= 1;
+  }
+  Mask |= 1;
+  Mask <<= (4 - DQMask.size());
+
+  return Mask;
+}
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteInstrumentor.h b/llvm/lib/Target/ARM/ARMSilhouetteInstrumentor.h
new file mode 100644
index 00000000000..a5e1e8ef7c6
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteInstrumentor.h
@@ -0,0 +1,203 @@
+//===- ARMSilhouetteInstrumentor - A helper class for instrumentation -----===//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines interfaces of the ARMSilhouetteInstrumentor class.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#ifndef ARM_SILHOUETTE_INSTRUMENTOR
+#define ARM_SILHOUETTE_INSTRUMENTOR
+
+#include "ARMBaseInstrInfo.h"
+#include "llvm/CodeGen/LivePhysRegs.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/TargetInstrInfo.h"
+#include "llvm/CodeGen/TargetSubtargetInfo.h"
+
+#include <deque>
+
+namespace llvm {
+  //====================================================================
+  // Static inline functions.
+  //====================================================================
+
+  //
+  // Function: getFunctionCodeSize()
+  //
+  // Description:
+  //   This function computes the code size of a machine function.
+  //
+  // Input:
+  //   MF - A reference to the target machine function.
+  //
+  // Return value:
+  //   The size (in bytes) of the machine function.
+  //
+  static inline unsigned long getFunctionCodeSize(const MachineFunction & MF) {
+    const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+    unsigned long CodeSize = 0ul;
+    for (const MachineBasicBlock & MBB : MF) {
+      for (const MachineInstr & MI : MBB) {
+        CodeSize += TII->getInstSizeInBytes(MI);
+      }
+    }
+
+    return CodeSize;
+  }
+
+  //
+  // Function: addImmediateToRegister()
+  //
+  // Description:
+  //   This function builds an ADD/SUB that adds an immediate to a register and
+  //   puts the new instruction(s) at the end of a deque.
+  //
+  // Inputs:
+  //   MI    - A reference to the instruction before which to insert new
+  //           instructions.
+  //   Reg   - The destination register.
+  //   Imm   - The immediate to be added.
+  //   Insts - A reference to a deque that contains new instructions.
+  //
+  static inline void
+  addImmediateToRegister(MachineInstr & MI, unsigned Reg, int64_t Imm,
+                         std::deque<MachineInstr *> & Insts) {
+    assert((Imm > -4096 && Imm < 4096) && "Immediate too large!");
+    assert((Reg != ARM::SP || Imm % 4 == 0) &&
+            "Cannot add unaligned immediate to SP!");
+
+    MachineFunction & MF = *MI.getMF();
+    const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+    unsigned PredReg;
+    ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+    unsigned addOpc = Imm < 0 ? ARM::t2SUBri12 : ARM::t2ADDri12;
+    if (Reg == ARM::SP && Imm > -512 && Imm < 512) {
+      addOpc = Imm < 0 ? ARM::tSUBspi : ARM::tADDspi;
+      Imm >>= 2;
+    }
+
+    Insts.push_back(BuildMI(MF, MI.getDebugLoc(), TII->get(addOpc), Reg)
+                    .addReg(Reg)
+                    .addImm(Imm < 0 ? -Imm : Imm)
+                    .add(predOps(Pred, PredReg)));
+  }
+
+  //
+  // Function: subtractImmediateFromRegister()
+  //
+  // Description:
+  //   This function builds a SUB/ADD that subtracts an immediate from a register
+  //   and puts the new instruction(s) at the end of a deque.
+  //
+  // Inputs:
+  //   MI    - A reference to the instruction before which to insert new
+  //           instructions.
+  //   Reg   - The destination register.
+  //   Imm   - The immediate to be subtracted.
+  //   Insts - A reference to a deque that contains new instructions.
+  //
+  static inline void
+  subtractImmediateFromRegister(MachineInstr & MI, unsigned Reg, int64_t Imm,
+                                std::deque<MachineInstr *> & Insts) {
+    addImmediateToRegister(MI, Reg, -Imm, Insts);
+  }
+
+  //
+  // Function: findFreeRegisters()
+  //
+  // Description:
+  //   This function computes the liveness of ARM core registers before a given
+  //   instruction MI and returns a list of free core registers that can be
+  //   used for instrumentation purposes.
+  //
+  // Inputs:
+  //   MI    - A reference to the instruction before which to find free
+  //           registers.
+  //   Thumb - Whether we are looking for Thumb registers (low registers, i,e,,
+  //           R0 -- R7) or ARM registers (both low and high registers, i.e.,
+  //           R0 -- R12 and LR).
+  //
+  // Return value:
+  //   A deque of free registers (might be empty, if none is found).
+  //
+  static inline std::deque<unsigned>
+  findFreeRegisters(const MachineInstr & MI, bool Thumb = false) {
+    const MachineFunction & MF = *MI.getMF();
+    const MachineBasicBlock & MBB = *MI.getParent();
+    const MachineRegisterInfo & MRI = MF.getRegInfo();
+    const TargetRegisterInfo * TRI = MF.getSubtarget().getRegisterInfo();
+    LivePhysRegs UsedRegs(*TRI);
+
+    // First add live-out registers of MBB; these registers are considered live
+    // at the end of MBB
+    UsedRegs.addLiveOuts(MBB);
+
+    // Then move backward step by step to compute live registers before MI
+    MachineBasicBlock::const_iterator MBBI(MI);
+    MachineBasicBlock::const_iterator I = MBB.end();
+    while (I != MBBI) {
+      UsedRegs.stepBackward(*--I);
+    }
+
+    // Now add registers that are neither reserved nor live to a free list
+    const auto LoGPRs = {
+      ARM::R0, ARM::R1, ARM::R2, ARM::R3, ARM::R4, ARM::R5, ARM::R6, ARM::R7,
+    };
+    const auto HiGPRs = {
+      ARM::R8, ARM::R9, ARM::R10, ARM::R11, ARM::R12, ARM::LR,
+    };
+    std::deque<unsigned> FreeRegs;
+    for (unsigned Reg : LoGPRs) {
+      if (!MRI.isReserved(Reg) && !UsedRegs.contains(Reg)) {
+        FreeRegs.push_back(Reg);
+      }
+    }
+    if (!Thumb) {
+      for (unsigned Reg : HiGPRs) {
+        if (!MRI.isReserved(Reg) && !UsedRegs.contains(Reg)) {
+          FreeRegs.push_back(Reg);
+        }
+      }
+    }
+
+    return FreeRegs;
+  }
+
+  //====================================================================
+  // Class ARMSilhouetteInstrumentor.
+  //====================================================================
+
+  struct ARMSilhouetteInstrumentor {
+    void insertInstBefore(MachineInstr & MI, MachineInstr * Inst);
+
+    void insertInstAfter(MachineInstr & MI, MachineInstr * Inst);
+
+    void insertInstsBefore(MachineInstr & MI,
+                           std::deque<MachineInstr *> & Insts);
+
+    void insertInstsAfter(MachineInstr & MI,
+                          std::deque<MachineInstr *> & Insts);
+
+    void removeInst(MachineInstr & MI);
+
+  private:
+    unsigned getITBlockSize(const MachineInstr & IT);
+    MachineInstr * findIT(MachineInstr & MI, unsigned & distance);
+    const MachineInstr * findIT(const MachineInstr & MI, unsigned & distance);
+    std::deque<bool> decodeITMask(unsigned Mask);
+    unsigned encodeITMask(std::deque<bool> DQMask);
+  };
+}
+
+#endif
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteLabelCFI.cpp b/llvm/lib/Target/ARM/ARMSilhouetteLabelCFI.cpp
new file mode 100644
index 00000000000..ffda5562864
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteLabelCFI.cpp
@@ -0,0 +1,422 @@
+//===-- ARMSilhouetteLabelCFI - Label-Based Forward Control-Flow Integrity ===//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass implements the label-based single-label control-flow integrity for
+// forward indirect control-flow transfer instructions on ARM.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#include "ARM.h"
+#include "ARMSilhouetteConvertFuncList.h"
+#include "ARMSilhouetteLabelCFI.h"
+#include "ARMTargetMachine.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/FileSystem.h"
+
+#include <vector>
+
+using namespace llvm;
+
+extern bool SilhouetteInvert;
+extern bool SilhouetteStr2Strt;
+
+static DebugLoc DL;
+
+char ARMSilhouetteLabelCFI::ID = 0;
+
+ARMSilhouetteLabelCFI::ARMSilhouetteLabelCFI()
+    : MachineFunctionPass(ID) {
+}
+
+StringRef
+ARMSilhouetteLabelCFI::getPassName() const {
+  return "ARM Silhouette Label-Based Forward CFI Pass";
+}
+
+//
+// Function: BackupReister()
+//
+// Description:
+//   This function inserts instructions that store the content of a lo register
+//   (R0 -- R7) onto the stack.
+//
+// Inputs:
+//   MI   - A reference to the instruction before which to insert instructions.
+//   Reg1 - The register to spill.
+//
+static void
+BackupRegister(MachineInstr & MI, unsigned Reg) {
+  MachineBasicBlock & MBB = *MI.getParent();
+  const TargetInstrInfo * TII = MBB.getParent()->getSubtarget().getInstrInfo();
+
+  if (SilhouetteInvert || !SilhouetteStr2Strt) {
+    // Build a PUSH
+    BuildMI(MBB, &MI, DL, TII->get(ARM::tPUSH))
+    .add(predOps(ARMCC::AL))
+    .addReg(Reg);
+  } else {
+    //
+    // Build the following instruction sequence:
+    //
+    // sub  sp, #4
+    // strt reg, [sp, #0]
+    //
+    BuildMI(MBB, &MI, DL, TII->get(ARM::tSUBspi), ARM::SP)
+    .addReg(ARM::SP)
+    .addImm(1)
+    .add(predOps(ARMCC::AL));
+    BuildMI(MBB, &MI, DL, TII->get(ARM::t2STRT))
+    .addReg(Reg)
+    .addReg(ARM::SP)
+    .addImm(0);
+  }
+}
+
+//
+// Function: RestoreRegister()
+//
+// Description:
+//   This function inserts instructions that load the content of a lo register
+//   (R0 -- R7) from the stack.
+//
+// Inputs:
+//   MI   - A reference to the instruction before which to insert instructions.
+//   Reg - The register to restore.
+//
+static void
+RestoreRegister(MachineInstr & MI, unsigned Reg) {
+  MachineBasicBlock & MBB = *MI.getParent();
+  const TargetInstrInfo * TII = MBB.getParent()->getSubtarget().getInstrInfo();
+
+  // Generate a POP that pops out the register content from stack
+  BuildMI(MBB, &MI, DL, TII->get(ARM::tPOP))
+  .add(predOps(ARMCC::AL))
+  .addReg(Reg);
+}
+
+//
+// Method: insertCFILabelForCall()
+//
+// Description:
+//   This method inserts the CFI label for call before a machine function.
+//
+// Input:
+//   MF - A reference to the machine function.
+//
+void
+ARMSilhouetteLabelCFI::insertCFILabelForCall(MachineFunction & MF) {
+  MachineBasicBlock & MBB = *MF.begin();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  // Use "movs r3, r3" as our CFI label
+  BuildMI(MBB, MBB.begin(), DL, TII->get(ARM::tMOVSr), ARM::R3)
+  .addReg(ARM::R3);
+}
+
+//
+// Method: insertCFILabelForJump()
+//
+// Description:
+//   This method inserts the CFI label for jump before a machine basic block.
+//
+// Input:
+//   MBB - A reference to a machine basic block.
+//
+void
+ARMSilhouetteLabelCFI::insertCFILabelForJump(MachineBasicBlock & MBB) {
+  const TargetInstrInfo * TII = MBB.getParent()->getSubtarget().getInstrInfo();
+
+  // Use "mov r0, r0" as our CFI label
+  BuildMI(MBB, MBB.begin(), DL, TII->get(ARM::tMOVr), ARM::R0)
+  .addReg(ARM::R0);
+}
+
+//
+// Method: insertCFICheck()
+//
+// Description:
+//   This method inserts a CFI check before a specified indirect forward
+//   control-flow transfer instruction that jumps to a target in a register.
+//
+// Inputs:
+//   MI    - A reference to the indirect forward control-flow transfer
+//           instruction.
+//   Reg   - The register used by @MI.
+//   Label - The correct label to check.
+//
+void
+ARMSilhouetteLabelCFI::insertCFICheck(MachineInstr & MI, unsigned Reg,
+                                      uint16_t Label) {
+  MachineBasicBlock & MBB = *MI.getParent();
+  const TargetInstrInfo * TII = MBB.getParent()->getSubtarget().getInstrInfo();
+
+  //
+  // Try to find a free register first.  If we are unlucky, spill and (later)
+  // restore R4.
+  //
+  unsigned ScratchReg;
+  std::deque<unsigned> FreeRegs = findFreeRegisters(MI);
+  if (!FreeRegs.empty()) {
+    ScratchReg = FreeRegs[0];
+  } else {
+    errs() << "[CFI] Unable to find a free register for " << MI;
+    ScratchReg = ARM::R4;
+    BackupRegister(MI, ScratchReg);
+  }
+
+  //
+  // Build the following instruction sequence:
+  //
+  // bfc   reg, #0, #1          ; optional
+  // ldrh  scratch, [reg, #0]
+  // cmp   scratch, #CFI_LABEL
+  // it    ne
+  // bfcne reg, #0, #32
+  // orr   reg, reg, #1         ; optional
+  //
+
+  //
+  // Clear the LSB of @Reg for instructions like BX and BLX; ARM uses the LSB
+  // to indicate an instruction set exchange between ARM and Thumb.
+  //
+  if (MI.getOpcode() != ARM::tBRIND) {
+    BuildMI(MBB, &MI, DL, TII->get(ARM::t2BFC), Reg)
+    .addReg(Reg)
+    .addImm(~0x1)
+    .add(predOps(ARMCC::AL));
+  }
+  // Load the target CFI label to @ScratchReg
+  BuildMI(MBB, &MI, DL, TII->get(ARM::t2LDRHi12), ScratchReg)
+  .addReg(Reg)
+  .addImm(0);
+  // Compare the target label with the correct label
+  assert(ARM_AM::getT2SOImmVal(Label) != -1 && "Invalid value for T2SOImm!");
+  BuildMI(MBB, &MI, DL, TII->get(ARM::t2CMPri))
+  .addReg(ScratchReg)
+  .addImm(Label);
+  // Clear all the bits of @Reg if two labels are not equal (a CFI violation)
+  BuildMI(MBB, &MI, DL, TII->get(ARM::t2IT))
+  .addImm(ARMCC::NE)
+  .addImm(0x8);
+  BuildMI(MBB, &MI, DL, TII->get(ARM::t2BFC), Reg)
+  .addReg(Reg)
+  .addImm(0)
+  .addImm(ARMCC::NE).addReg(ARM::CPSR, RegState::Kill);
+  // Set the LSB of @Reg for instructions like BX and BLX
+  if (MI.getOpcode() != ARM::tBRIND) {
+    BuildMI(MBB, &MI, DL, TII->get(ARM::t2ORRri), Reg)
+    .addReg(Reg)
+    .addImm(0x1)
+    .add(predOps(ARMCC::AL))
+    .add(condCodeOp());
+  }
+
+  // Restore the scratch register if we spilled it
+  if (FreeRegs.empty()) {
+    RestoreRegister(MI, ScratchReg);
+  }
+}
+
+//
+// Method: insertCFICheckForCall()
+//
+// Description:
+//   This method inserts a CFI check before a specified indirect call
+//   instruction that calls a target function in a register.
+//
+// Inputs:
+//   MI    - A reference to the indirect call instruction.
+//   Reg   - The register used by @MI.
+//   Label - The correct label to check.
+//
+void
+ARMSilhouetteLabelCFI::insertCFICheckForCall(MachineInstr & MI, unsigned Reg) {
+  insertCFICheck(MI, Reg, CFI_LABEL_CALL);
+}
+
+//
+// Method: insertCFICheckForJump()
+//
+// Description:
+//   This method inserts a CFI check before a specified indirect jump
+//   instruction that jumps to a target in a register.
+//
+// Inputs:
+//   MI    - A reference to the indirect jump instruction.
+//   Reg   - The register used by @MI.
+//   Label - The correct label to check.
+//
+void
+ARMSilhouetteLabelCFI::insertCFICheckForJump(MachineInstr & MI, unsigned Reg) {
+  insertCFICheck(MI, Reg, CFI_LABEL_JMP);
+}
+
+//
+// Method: runOnMachineFunction()
+//
+// Description:
+//   This method is called when the PassManager wants this pass to transform
+//   the specified MachineFunction.  This method .
+//
+// Input:
+//   MF - A reference to the MachineFunction to transform.
+//
+// Output:
+//   MF - The transformed MachineFunction.
+//
+// Return value:
+//   true  - The MachineFunction was transformed.
+//   false - The MachineFunction was not transformed.
+//
+bool
+ARMSilhouetteLabelCFI::runOnMachineFunction(MachineFunction & MF) {
+#if 1
+  // Skip certain functions
+  if (funcBlacklist.find(MF.getName()) != funcBlacklist.end()) {
+    return false;
+  }
+  // Skip privileged functions in FreeRTOS
+  if (MF.getFunction().getSection().equals("privileged_functions")){
+    errs() << "Privileged function! skipped\n";
+    return false;
+  }
+#endif
+
+  unsigned long OldCodeSize = getFunctionCodeSize(MF);
+
+  //
+  // Iterate through all the instructions within the function to locate
+  // indirect branches and calls.
+  //
+  std::vector<MachineInstr *> IndirectBranches;
+  std::vector<MachineInstr *> JTJs;
+  for (MachineBasicBlock & MBB : MF) {
+    for (MachineInstr & MI : MBB) {
+      switch (MI.getOpcode()) {
+      // Indirect branch
+      case ARM::tBRIND:     // 0: GPR, 1: predCC, 2: predReg
+      case ARM::tBX:        // 0: GPR, 1: predCC, 2: predReg
+      case ARM::tBXNS:      // 0: GPR, 1: predCC, 2: predReg
+      // Indirect call
+      case ARM::tBLXr:      // 0: predCC, 1: predReg, 2: GPR
+      case ARM::tBLXNSr:    // 0: predCC, 1: predReg, 2: GPRnopc
+      case ARM::tBX_CALL:   // 0: tGPR
+      case ARM::tTAILJMPr:  // 0: tcGPR
+        IndirectBranches.push_back(&MI);
+        break;
+
+      // Jump table jump is complicated and not dealt with for now
+      case ARM::tBR_JTr:    // 0: tGPR, 1: i32imm
+      case ARM::tTBB_JT:    // 0: tGPR, 1: tGPR, 2: i32imm, 3: i32imm
+      case ARM::tTBH_JT:    // 0: tGPR, 1: tGPR, 2: i32imm, 3: i32imm
+      case ARM::t2BR_JT:    // 0: GPR, 1: GPR, 2: i32imm
+      case ARM::t2TBB_JT:   // 0: GPR, 1: GPR, 2: i32imm, 3: i32imm
+      case ARM::t2TBH_JT:   // 0: GPR, 1: GPR, 2: i32imm, 3: i32imm
+        JTJs.push_back(&MI);
+        break;
+
+      //
+      // Also list direct {function, system, hyper} calls here to make the
+      // default branch be able to use MI.isCall().
+      //
+      case ARM::tBL:
+      case ARM::tBLXi:
+      case ARM::tTAILJMPd:
+      case ARM::tTAILJMPdND:
+      case ARM::tSVC:
+      case ARM::t2SMC:
+      case ARM::t2HVC:
+        break;
+
+      default:
+        if (MI.isIndirectBranch() || MI.isCall()) {
+          errs() << "[CFI]: unidentified branch/call: " << MI;
+        }
+        break;
+      }
+    }
+  }
+
+#if 1
+  //
+  // Insert a CFI label before the function if it is visible to other
+  // compilation units or has its address taken.
+  //
+  const Function & F = MF.getFunction();
+  if ((!F.hasInternalLinkage() && !F.hasPrivateLinkage()) ||
+      F.hasAddressTaken()) {
+    if (MF.begin() != MF.end()) {
+      insertCFILabelForCall(MF);
+    }
+  }
+#else
+  // Insert a CFI label before the function
+  if (MF.begin() != MF.end()) {
+    insertCFILabel(MF);
+  }
+#endif
+
+  //
+  // Insert a CFI check before each indirect branch and call, and insert a CFI
+  // label before every successor MBB of each indirect branch.
+  //
+  for (MachineInstr * MI : IndirectBranches) {
+    switch (MI->getOpcode()) {
+    case ARM::tBRIND:     // 0: GPR, 1: predCC, 2: predReg
+    case ARM::tBX:        // 0: GPR, 1: predCC, 2: predReg
+    case ARM::tBXNS:      // 0: GPR, 1: predCC, 2: predReg
+      for (MachineBasicBlock * SuccMBB : MI->getParent()->successors()) {
+        insertCFILabelForJump(*SuccMBB);
+      }
+      insertCFICheckForJump(*MI, MI->getOperand(0).getReg());
+      break;
+
+    case ARM::tBLXr:      // 0: predCC, 1: predReg, 2: GPR
+    case ARM::tBLXNSr:    // 0: predCC, 1: predReg, 2: GPRnopc
+      insertCFICheckForCall(*MI, MI->getOperand(2).getReg());
+      break;
+
+    case ARM::tBX_CALL:   // 0: tGPR
+    case ARM::tTAILJMPr:  // 0: tcGPR
+      insertCFICheckForCall(*MI, MI->getOperand(0).getReg());
+      break;
+
+    default:
+      llvm_unreachable("Unexpected opcode");
+    }
+  }
+
+  unsigned long NewCodeSize = getFunctionCodeSize(MF);
+
+  // Output code size information
+  std::error_code EC;
+  raw_fd_ostream MemStat("./code_size_cfi.stat", EC,
+                         sys::fs::OpenFlags::F_Append);
+  MemStat << MF.getName() << ":" << OldCodeSize << ":" << NewCodeSize << "\n";
+
+  // Output jump table jump information
+  raw_fd_ostream JTJStat("./jump_table_jump.stat", EC,
+                         sys::fs::OpenFlags::F_Append);
+  for (MachineInstr * MI : JTJs) {
+    JTJStat << MI->getMF()->getName() << "\n";
+  }
+
+  return true;
+}
+
+namespace llvm {
+  FunctionPass * createARMSilhouetteLabelCFI(void) {
+    return new ARMSilhouetteLabelCFI();
+  }
+}
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteLabelCFI.h b/llvm/lib/Target/ARM/ARMSilhouetteLabelCFI.h
new file mode 100644
index 00000000000..22ca272d97e
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteLabelCFI.h
@@ -0,0 +1,50 @@
+//===-- ARMSilhouetteLabelCFI - Label-Based Forward Control-Flow Integrity ===//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass implements the label-based single-label control-flow integrity for
+// forward indirect control-flow transfer instructions on ARM.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#ifndef ARM_SILHOUETTE_LABEL_CFI
+#define ARM_SILHOUETTE_LABEL_CFI
+
+#include "ARMSilhouetteInstrumentor.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+
+namespace llvm {
+  struct ARMSilhouetteLabelCFI
+      : public MachineFunctionPass, ARMSilhouetteInstrumentor {
+    // pass identifier variable
+    static char ID;
+
+    // The constant CFI label for indirect calls (encoding of "movs r3, r3")
+    static const uint16_t CFI_LABEL_CALL = 0x001b;
+    // The constant CFI label for indirect jumps (encoding of "mov r0, r0")
+    static const uint16_t CFI_LABEL_JMP = 0x4600;
+
+    ARMSilhouetteLabelCFI();
+
+    virtual StringRef getPassName() const override;
+
+    virtual bool runOnMachineFunction(MachineFunction & MF) override;
+
+  private:
+    void insertCFILabelForCall(MachineFunction & MF);
+    void insertCFILabelForJump(MachineBasicBlock & MBB);
+    void insertCFICheckForCall(MachineInstr & MI, unsigned Reg);
+    void insertCFICheckForJump(MachineInstr & MI, unsigned Reg);
+    void insertCFICheck(MachineInstr & MI, unsigned Reg, uint16_t Label);
+  };
+
+  FunctionPass * createARMSilhouetteLabelCFI(void);
+}
+
+#endif
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteSFI.cpp b/llvm/lib/Target/ARM/ARMSilhouetteSFI.cpp
new file mode 100644
index 00000000000..a5de8cb185a
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteSFI.cpp
@@ -0,0 +1,604 @@
+//===-- ARMSilhouetteSFI - Software Fault Isolation on stores -------------===//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass applies bit-masking on addresses that the generated code stores
+// into, either selectively (applying to only heavyweight stores) or entirely.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#include "ARM.h"
+#include "ARMSilhouetteConvertFuncList.h"
+#include "ARMSilhouetteSFI.h"
+#include "ARMTargetMachine.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/FileSystem.h"
+
+#include <deque>
+
+using namespace llvm;
+
+extern SilhouetteSFIOption SilhouetteSFI;
+
+char ARMSilhouetteSFI::ID = 0;
+
+static DebugLoc DL;
+
+ARMSilhouetteSFI::ARMSilhouetteSFI()
+    : MachineFunctionPass(ID) {
+}
+
+StringRef
+ARMSilhouetteSFI::getPassName() const {
+  return "ARM Silhouette Store SFI Pass";
+}
+
+//
+// Function: immediateStoreOpcode()
+//
+// Description:
+//   This function takes an opcode of a 2-register store (i.e., a store with 2
+//   registers as a memory operand) and returns the opcode of its corresponding
+//   register-immediate store (i.e., a store whose memory operand consists of a
+//   register and an immediate).
+//
+// Input:
+//   opcode - The opcode of a two-register store.
+//
+// Return value:
+//   The opcode of the corresponding register-immediate store.
+//
+static unsigned
+immediateStoreOpcode(unsigned opcode) {
+  switch (opcode) {
+  case ARM::tSTRr:
+    return ARM::tSTRi;
+
+  case ARM::t2STRs:
+    return ARM::t2STRi12;
+
+  case ARM::tSTRHr:
+    return ARM::tSTRHi;
+
+  case ARM::t2STRHs:
+    return ARM::t2STRHi12;
+
+  case ARM::tSTRBr:
+    return ARM::tSTRBi;
+
+  case ARM::t2STRBs:
+    return ARM::t2STRBi12;
+
+  default:
+    llvm_unreachable("Unexpected opcode!");
+  }
+}
+
+//
+// Function: doBitmasking()
+//
+// Description:
+//   This function applies bit-masking on a register.
+//
+// Inputs:
+//   MI    - A reference to the store instruction before which to insert new
+//           instructions.
+//   Reg   - The register to bit-mask.
+//   Insts - A reference to a deque that contains new instructions.
+//
+static void
+doBitmasking(MachineInstr & MI, unsigned Reg, std::deque<MachineInstr *> & Insts) {
+  MachineFunction & MF = *MI.getMF();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  unsigned PredReg;
+  ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+  Insts.push_back(BuildMI(MF, DL, TII->get(ARM::t2BICri), Reg)
+                  .addReg(Reg)
+                  .addImm(SFI_MASK)
+                  .add(predOps(Pred, PredReg))
+                  .add(condCodeOp()));
+  Insts.push_back(BuildMI(MF, DL, TII->get(ARM::t2BICri), Reg)
+                  .addReg(Reg)
+                  .addImm(SFI_MASK2)
+                  .add(predOps(Pred, PredReg))
+                  .add(condCodeOp()));
+}
+
+//
+// Function: handleSPUncommonImmediate()
+//
+// Description:
+//   This function takes care of cases where the base register of a store is SP
+//   and the immediate offset is either not aligned by 4 or too large.  It is
+//   caller's responsibility to update MI's base register to the return value
+//   and immediate to 0 after the function call.
+//
+// Inputs:
+//   MI          - A reference to the store instruction before and after which
+//                 to insert new instructions.
+//   SrcReg      - The source register of MI.
+//   Imm         - The immediate of MI.
+//   InstsBefore - A reference to a deque that contains new instructions to
+//                 insert before MI.
+//   InstsAfter  - A reference to a deque that contains new instructions to
+//                 insert after MI.
+//   SrcReg2     - The second source register of MI in case MI is a double
+//                 word store.
+//
+// Return value:
+//   The new base register.
+//
+static unsigned
+handleSPUncommonImmediate(MachineInstr & MI, unsigned SrcReg, int64_t Imm,
+                          std::deque<MachineInstr *> & InstsBefore,
+                          std::deque<MachineInstr *> & InstsAfter,
+                          unsigned SrcReg2 = ARM::NoRegister) {
+  MachineFunction & MF = *MI.getMF();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  unsigned PredReg;
+  ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+  // Save a scratch register onto the stack.  Note that we are introducing a
+  // new store here, so this store needs to be instrumented as well.
+  unsigned ScratchReg = ARM::R0;
+  while (ScratchReg == SrcReg || ScratchReg == SrcReg2) ScratchReg++;
+  doBitmasking(MI, ARM::SP, InstsBefore);
+  InstsBefore.push_back(BuildMI(MF, DL, TII->get(ARM::tPUSH))
+                        .add(predOps(Pred, PredReg))
+                        .addReg(ScratchReg));
+  Imm += 4; // Compensate for SP decrement
+
+  // Add SP with the unaligned immediate to the scratch register
+  unsigned addOpc = Imm < 0 ? ARM::t2SUBri12 : ARM::t2ADDri12;
+  InstsBefore.push_back(BuildMI(MF, DL, TII->get(addOpc), ScratchReg)
+                        .addReg(ARM::SP)
+                        .addImm(Imm < 0 ? -Imm : Imm)
+                        .add(predOps(Pred, PredReg)));
+
+  // Do bit-masking
+  doBitmasking(MI, ScratchReg, InstsBefore);
+
+  // Restore the scratch register from the stack
+  InstsAfter.push_back(BuildMI(MF, DL, TII->get(ARM::tPOP))
+                       .add(predOps(Pred, PredReg))
+                       .addReg(ScratchReg));
+
+  return ScratchReg;
+}
+
+//
+// Method: runOnMachineFunction()
+//
+// Description:
+//   This method is called when the PassManager wants this pass to transform
+//   the specified MachineFunction.  This method applies bit-masking on the
+//   address to which a store instruction writes, either for all regular stores
+//   or selectively (applying to only heavyweight stores).
+//
+// Inputs:
+//   MF - A reference to the MachineFunction to transform.
+//
+// Outputs:
+//   MF - The transformed MachineFunction.
+//
+// Return value:
+//   true  - The MachineFunction was transformed.
+//   false - The MachineFunction was not transformed.
+//
+bool
+ARMSilhouetteSFI::runOnMachineFunction(MachineFunction & MF) {
+#if 1
+  // Skip certain functions
+  if (funcBlacklist.find(MF.getName()) != funcBlacklist.end()) {
+    return false;
+  }
+#endif
+
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  unsigned long OldCodeSize = getFunctionCodeSize(MF);
+
+  // Iterate over all machine instructions to find stores
+  std::deque<MachineInstr *> Stores;
+  for (MachineBasicBlock & MBB : MF) {
+    for (MachineInstr & MI : MBB) {
+      if (!MI.mayStore() || MI.getFlag(MachineInstr::ShadowStack)) {
+        continue;
+      }
+
+      switch (MI.getOpcode()) {
+      // Store word immediate
+      case ARM::tSTRi:       // A7.7.158 Encoding T1
+      case ARM::tSTRspi:     // A7.7.158 Encoding T2
+      case ARM::t2STRi12:    // A7.7.158 Encoding T3
+      case ARM::t2STRi8:     // A7.7.158 Encoding T4; no write-back
+      // Store halfword immediate
+      case ARM::tSTRHi:      // A7.7.167 Encoding T1
+      case ARM::t2STRHi12:   // A7.7.167 Encoding T2
+      case ARM::t2STRHi8:    // A7.7.167 Encoding T3; no write-back
+      // Store byte immediate
+      case ARM::tSTRBi:      // A7.7.160 Encoding T1
+      case ARM::t2STRBi12:   // A7.7.160 Encoding T2
+      case ARM::t2STRBi8:    // A7.7.160 Encoding T3; no write-back
+      // Store word with write-back
+      case ARM::t2STR_PRE:   // A7.7.158 Encoding T4; pre-indexed
+      case ARM::t2STR_POST:  // A7.7.158 Encoding T4; post-indexed
+      // Store halfword with write-back
+      case ARM::t2STRH_PRE:  // A7.7.167 Encoding T3; pre-indexed
+      case ARM::t2STRH_POST: // A7.7.167 Encoding T3; post-indexed
+      // Store byte with write-back
+      case ARM::t2STRB_PRE:  // A7.7.160 Encoding T3; pre-indexed
+      case ARM::t2STRB_POST: // A7.7.160 Encoding T3; post-indexed
+      // Store word register
+      case ARM::tSTRr:       // A7.7.159 Encoding T1
+      case ARM::t2STRs:      // A7.7.159 Encoding T2
+      // Store halfword register
+      case ARM::tSTRHr:      // A7.7.168 Encoding T1
+      case ARM::t2STRHs:     // A7.7.168 Encoding T2
+      // Store byte register
+      case ARM::tSTRBr:      // A7.7.161 Encoding T1
+      case ARM::t2STRBs:     // A7.7.161 Encoding T2
+      // Store dual
+      case ARM::t2STRDi8:    // A7.7.163 Encoding T1; no write-back
+      case ARM::t2STRD_PRE:  // A7.7.163 Encoding T1; pre-indexed
+      case ARM::t2STRD_POST: // A7.7.163 Encoding T1; post-indexed
+        // Lightweight stores; instrument them only if we are using full SFI
+        if (SilhouetteSFI == FullSFI) {
+          Stores.push_back(&MI);
+        }
+        break;
+
+      // Floating-point store
+      case ARM::VSTRD:       // A7.7.256 Encoding T1
+      case ARM::VSTRS:       // A7.7.256 Encoding T2
+      // Store multiple
+      case ARM::tSTMIA_UPD:  // A7.7.156 Encoding T1
+      case ARM::t2STMIA:     // A7.7.156 Encoding T2; no write-back
+      case ARM::t2STMIA_UPD: // A7.7.156 Encoding T2; with write-back
+      case ARM::t2STMDB:     // A7.7.157 Encoding T1; no write-back
+      case ARM::t2STMDB_UPD: // A7.7.157 Encoding T1; with write-back
+      // Push
+      case ARM::tPUSH:       // A7.7.99 Encoding T1
+      // Floating-point store multiple
+      case ARM::VSTMDIA:     // A7.7.255 Encoding T1; increment after; no write-back
+      case ARM::VSTMDIA_UPD: // A7.7.255 Encoding T1; increment after; with write-back
+      case ARM::VSTMDDB_UPD: // A7.7.255 Encoding T1; decrement before; with write-back
+      case ARM::VSTMSIA:     // A7.7.255 Encoding T2; increment after; no write-back
+      case ARM::VSTMSIA_UPD: // A7.7.255 Encoding T2; increment after; with write-back
+      case ARM::VSTMSDB_UPD: // A7.7.255 Encoding T2; decrement before; with write-back
+        // Heavyweight stores; leave them as is only if we are not using SFI
+        if (SilhouetteSFI != NoSFI) {
+          Stores.push_back(&MI);
+        }
+        break;
+
+      case ARM::INLINEASM:
+        break;
+
+      default:
+        errs() << "[SFI] Unidentified store: " << MI;
+        break;
+      }
+    }
+  }
+
+  // Instrument each different type of stores
+  for (MachineInstr * Store : Stores) {
+    MachineInstr & MI = *Store;
+
+    unsigned PredReg;
+    ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+    unsigned BaseReg, OffsetReg;
+    int64_t Imm;
+
+    std::deque<MachineInstr *> InstsBefore;
+    std::deque<MachineInstr *> InstsAfter;
+    switch (MI.getOpcode()) {
+    // A7.7.158 Encoding T1: STR<c> <Rt>,[<Rn>{,#<imm5>}]
+    case ARM::tSTRi:
+    // A7.7.167 Encoding T1: STRH<c> <Rt>,[<Rn>{,#<imm5>}]
+    case ARM::tSTRHi:
+    // A7.7.160 Encoding T1: STRB<c> <Rt>,[<Rn>{,#<imm5>}]
+    case ARM::tSTRBi:
+      BaseReg = MI.getOperand(1).getReg();
+      // The immediate is small enough; just bit-mask and store
+      doBitmasking(MI, BaseReg, InstsBefore);
+      break;
+
+    // A7.7.158 Encoding T2: STR<c> <Rt>,[SP,#<imm8>]
+    case ARM::tSTRspi:
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm() << 2; // Not ZeroExtend(imm8:'00', 32) yet
+      if (Imm < 256) {
+        // For a small immediate, just bit-mask and store.
+        doBitmasking(MI, BaseReg, InstsBefore);
+      } else {
+        // For a large immediate, handle it separately.
+        BaseReg = handleSPUncommonImmediate(MI, MI.getOperand(0).getReg(), Imm,
+                                            InstsBefore, InstsAfter);
+        MI.setDesc(TII->get(ARM::t2STRi12));
+        MI.getOperand(1).setReg(BaseReg);
+        MI.getOperand(2).setImm(0);
+      }
+      break;
+
+    // A7.7.158 Encoding T3: STR<c>.W <Rt>,[<Rn>,#<imm12>]
+    case ARM::t2STRi12:
+    // A7.7.167 Encoding T2: STRH<c>.W <Rt>,[<Rn>,#<imm12>]
+    case ARM::t2STRHi12:
+    // A7.7.160 Encoding T2: STRB<c>.W <Rt>,[<Rn>,#<imm12>]
+    case ARM::t2STRBi12:
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm();
+      // For a small immediate, just bit-mask and store
+      if (Imm < 256) {
+        doBitmasking(MI, BaseReg, InstsBefore);
+        break;
+      }
+      if (BaseReg == ARM::SP) {
+        // Special-case SP as it should not be incremented
+        BaseReg = handleSPUncommonImmediate(MI, MI.getOperand(0).getReg(), Imm,
+                                            InstsBefore, InstsAfter);
+        MI.getOperand(1).setReg(BaseReg);
+        MI.getOperand(2).setImm(0);
+      } else {
+        // Add, bit-mask, store, and subtract
+        addImmediateToRegister(MI, BaseReg, Imm, InstsBefore);
+        MI.getOperand(2).setImm(0);
+        doBitmasking(MI, BaseReg, InstsBefore);
+        subtractImmediateFromRegister(MI, BaseReg, Imm, InstsAfter);
+      }
+      break;
+
+    // A7.7.158 Encoding T4: STR<c> <Rt>,[<Rn>,#-<imm8>]
+    case ARM::t2STRi8:
+    // A7.7.167 Encoding T3: STRH<c> <Rt>,[<Rn>,#-<imm8>]
+    case ARM::t2STRHi8:
+    // A7.7.160 Encoding T3: STRB<c> <Rt>,[<Rn>,#-<imm8>]
+    case ARM::t2STRBi8:
+      BaseReg = MI.getOperand(1).getReg();
+      // The immediate is small enough; just bit-mask and store
+      doBitmasking(MI, BaseReg, InstsBefore);
+      break;
+
+    // A7.7.158 Encoding T4: STR<c> <Rt>,[<Rn>,#+/-<imm8>]!
+    case ARM::t2STR_PRE:
+    // A7.7.167 Encoding T3: STRH<c> <Rt>,[<Rn>,#+/-<imm8>]!
+    case ARM::t2STRH_PRE:
+    // A7.7.160 Encoding T3: STRB<c> <Rt>,[<Rn>,#+/-<imm8>]!
+    case ARM::t2STRB_PRE:
+      BaseReg = MI.getOperand(0).getReg();
+      // Pre-indexed stores: just bit-mask and store
+      doBitmasking(MI, BaseReg, InstsBefore);
+      break;
+
+    // A7.7.158 Encoding T4: STR<c> <Rt>,[<Rn>],#+/-<imm8>
+    case ARM::t2STR_POST:
+    // A7.7.167 Encoding T3: STRH<c> <Rt>,[<Rn>],#+/-<imm8>
+    case ARM::t2STRH_POST:
+    // A7.7.160 Encoding T3: STRB<c> <Rt>,[<Rn>],#+/-<imm8>
+    case ARM::t2STRB_POST:
+      BaseReg = MI.getOperand(0).getReg();
+      // Post-indexed stores: just bit-mask and store
+      doBitmasking(MI, BaseReg, InstsBefore);
+      break;
+
+    // A7.7.159 Encoding T1: STR<c> <Rt>,[<Rn>,<Rm>]
+    case ARM::tSTRr:
+    // A7.7.168 Encoding T1: STRH<c> <Rt>,[<Rn>,<Rm>]
+    case ARM::tSTRHr:
+    // A7.7.161 Encoding T1: STRB<c> <Rt>,[<Rn>,<Rm>]
+    case ARM::tSTRBr:
+      BaseReg = MI.getOperand(1).getReg();
+      OffsetReg = MI.getOperand(2).getReg();
+      // Add, bit-mask, store, and subtract
+      InstsBefore.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrr), BaseReg)
+                            .addReg(BaseReg)
+                            .addReg(OffsetReg)
+                            .add(predOps(Pred, PredReg))
+                            .add(condCodeOp()));
+      doBitmasking(MI, BaseReg, InstsBefore);
+      // Need to change tSTR[BH]r to tSTR[BH]i
+      MI.setDesc(TII->get(immediateStoreOpcode(MI.getOpcode())));
+      MI.getOperand(2).ChangeToImmediate(0);
+      InstsAfter.push_back(BuildMI(MF, DL, TII->get(ARM::t2SUBrr), BaseReg)
+                           .addReg(BaseReg)
+                           .addReg(OffsetReg)
+                           .add(predOps(Pred, PredReg))
+                           .add(condCodeOp()));
+      break;
+
+    // A7.7.159 Encoding T2: STR<c>.W <Rt>,[<Rn>,<Rm>{,LSL #<imm2>}]
+    case ARM::t2STRs:
+    // A7.7.168 Encoding T2: STRH<c>.W <Rt>,[<Rn>,<Rm>{,LSL #<imm2>}]
+    case ARM::t2STRHs:
+    // A7.7.161 Encoding T2: STRB<c>.W <Rt>,[<Rn>,<Rm>{,LSL #<imm2>}]
+    case ARM::t2STRBs:
+      BaseReg = MI.getOperand(1).getReg();
+      OffsetReg = MI.getOperand(2).getReg();
+      Imm = ARM_AM::getSORegOpc(ARM_AM::lsl, MI.getOperand(3).getImm());
+      // Add, bit-mask, store, and subtract
+      InstsBefore.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrs), BaseReg)
+                            .addReg(BaseReg)
+                            .addReg(OffsetReg)
+                            .addImm(Imm)
+                            .add(predOps(Pred, PredReg))
+                            .add(condCodeOp()));
+      doBitmasking(MI, BaseReg, InstsBefore);
+      // Need to change t2STR[BH]s to t2STR[BH]i12
+      MI.setDesc(TII->get(immediateStoreOpcode(MI.getOpcode())));
+      MI.getOperand(2).ChangeToImmediate(0);
+      MI.RemoveOperand(3);
+      InstsAfter.push_back(BuildMI(MF, DL, TII->get(ARM::t2SUBrs), BaseReg)
+                           .addReg(BaseReg)
+                           .addReg(OffsetReg)
+                           .addImm(Imm)
+                           .add(predOps(Pred, PredReg))
+                           .add(condCodeOp()));
+      break;
+
+    // A7.7.163 Encoding T1: STRD<c> <Rt>,<Rt2>,[<Rn>{,#+/-<imm8>}]
+    case ARM::t2STRDi8:
+      BaseReg = MI.getOperand(2).getReg();
+      Imm = MI.getOperand(3).getImm(); // Already ZeroExtend(imm8:'00', 32)
+      // For a small immediate, just bit-mask and store
+      if (Imm >= -256 && Imm < 256) {
+        doBitmasking(MI, BaseReg, InstsBefore);
+        break;
+      }
+      if (BaseReg == ARM::SP) {
+        // Special-case SP as it should not be incremented
+        BaseReg = handleSPUncommonImmediate(MI, MI.getOperand(0).getReg(), Imm,
+                                            InstsBefore, InstsAfter,
+                                            MI.getOperand(1).getReg());
+        MI.getOperand(2).setReg(BaseReg);
+        MI.getOperand(3).setImm(0);
+      } else {
+        // Add, bit-mask, store, and subtract
+        addImmediateToRegister(MI, BaseReg, Imm, InstsBefore);
+        MI.getOperand(3).setImm(0);
+        doBitmasking(MI, BaseReg, InstsBefore);
+        subtractImmediateFromRegister(MI, BaseReg, Imm, InstsAfter);
+      }
+      break;
+
+    // A7.7.163 Encoding T1: STRD<c> <Rt>,<Rt2>,[<Rn>,#+/-<imm8>]!
+    case ARM::t2STRD_PRE:
+      BaseReg = MI.getOperand(0).getReg();
+      Imm = MI.getOperand(4).getImm(); // Already ZeroExtend(imm8:'00', 32)
+      // For a small immediate, just bit-mask and store
+      if (Imm >= -256 && Imm < 256) {
+        doBitmasking(MI, BaseReg, InstsBefore);
+        break;
+      }
+      if (BaseReg == ARM::SP) {
+        // Special-case SP as it should not be incremented
+        BaseReg = handleSPUncommonImmediate(MI, MI.getOperand(1).getReg(), Imm,
+                                            InstsBefore, InstsAfter,
+                                            MI.getOperand(2).getReg());
+        MI.getOperand(0).setReg(BaseReg);
+        MI.getOperand(4).setImm(0);
+      } else {
+        // Pre-indexed store: add, bit-mask, and store
+        addImmediateToRegister(MI, BaseReg, Imm, InstsBefore);
+        MI.getOperand(4).setImm(0);
+        doBitmasking(MI, BaseReg, InstsBefore);
+      }
+      break;
+
+    // A7.7.163 Encoding T1: STRD<c> <Rt>,<Rt2>,[<Rn>],#+/-<imm8>
+    case ARM::t2STRD_POST:
+      BaseReg = MI.getOperand(0).getReg();
+      // Post-indexed store: just bit-mask and store
+      doBitmasking(MI, BaseReg, InstsBefore);
+      break;
+
+    // A7.7.256 Encoding T1: VSTR<c> <Dd>,[<Rn>{,#+/-<imm8>}]
+    case ARM::VSTRD:
+    // A7.7.256 Encoding T2: VSTR<c> <Sd>,[<Rn>{,#+/-<imm8>}]
+    case ARM::VSTRS:
+      BaseReg = MI.getOperand(1).getReg();
+      // Not ZeroExtend(imm8:'00', 32) yet
+      Imm = ARM_AM::getAM5Offset(MI.getOperand(2).getImm()) << 2;
+      if (ARM_AM::getAM5Op(MI.getOperand(2).getImm()) == ARM_AM::AddrOpc::sub) {
+        Imm = -Imm;
+      }
+      // For a small immediate, just bit-mask and store
+      if (Imm >= -256 && Imm < 256) {
+        doBitmasking(MI, BaseReg, InstsBefore);
+        break;
+      }
+      if (BaseReg == ARM::SP) {
+        // Special-case SP as it should not be incremented
+        BaseReg = handleSPUncommonImmediate(MI, ARM::NoRegister, Imm,
+                                            InstsBefore, InstsAfter);
+        MI.getOperand(1).setReg(BaseReg);
+        MI.getOperand(2).setImm(ARM_AM::getAM5Opc(ARM_AM::AddrOpc::add, 0));
+      } else {
+        // Add, bit-mask, store, and subtract
+        addImmediateToRegister(MI, BaseReg, Imm, InstsBefore);
+        MI.getOperand(2).setImm(ARM_AM::getAM5Opc(ARM_AM::AddrOpc::add, 0));
+        doBitmasking(MI, BaseReg, InstsBefore);
+        subtractImmediateFromRegister(MI, BaseReg, Imm, InstsAfter);
+      }
+      break;
+
+    // A7.7.99 Encoding T1: PUSH<c> <registers>
+    case ARM::tPUSH:
+      BaseReg = ARM::SP;
+      // Push: just bit-mask and store
+      doBitmasking(MI, BaseReg, InstsBefore);
+      break;
+
+    // A7.7.156 Encoding T1: STM<c> <Rn>!,<registers>
+    case ARM::tSTMIA_UPD:
+    // A7.7.156 Encoding T2; STM<c>.W <Rn>,<registers>
+    case ARM::t2STMIA:
+    // A7.7.156 Encoding T2; STM<c>.W <Rn>!,<registers>
+    case ARM::t2STMIA_UPD:
+    // A7.7.157 Encoding T1; STMDB<c> <Rn>,<registers>
+    case ARM::t2STMDB:
+    // A7.7.157 Encoding T1; STMDB<c> <Rn>!,<registers>
+    case ARM::t2STMDB_UPD:
+    // A7.7.255 Encoding T1: VSTMDIA<c> <Rn>,<list>
+    case ARM::VSTMDIA:
+    // A7.7.255 Encoding T1: VSTMDIA<c> <Rn>!,<list>
+    case ARM::VSTMDIA_UPD:
+    // A7.7.255 Encoding T1: VSTMDDB<c> <Rn>!,<list>
+    case ARM::VSTMDDB_UPD:
+    // A7.7.255 Encoding T2: VSTMSIA<c> <Rn>,<list>
+    case ARM::VSTMSIA:
+    // A7.7.255 Encoding T2: VSTMSIA<c> <Rn>!,<list>
+    case ARM::VSTMSIA_UPD:
+    // A7.7.255 Encoding T2: VSTMSDB<c> <Rn>!,<list>
+    case ARM::VSTMSDB_UPD:
+      BaseReg = MI.getOperand(0).getReg();
+      // Store multiple: just bit-mask and store
+      doBitmasking(MI, BaseReg, InstsBefore);
+      break;
+
+    default:
+      llvm_unreachable("Unexpected opcode!");
+    }
+
+    if (!InstsBefore.empty()) {
+      insertInstsBefore(MI, InstsBefore);
+    }
+    if (!InstsAfter.empty()) {
+      insertInstsAfter(MI, InstsAfter);
+    }
+  }
+
+  unsigned long NewCodeSize = getFunctionCodeSize(MF);
+
+  // Output code size information
+  std::error_code EC;
+  raw_fd_ostream MemStat("./code_size_sfi.stat", EC,
+                         sys::fs::OpenFlags::F_Append);
+  MemStat << MF.getName() << ":" << OldCodeSize << ":" << NewCodeSize << "\n";
+
+  return true;
+}
+
+//
+// Create a new pass.
+//
+namespace llvm {
+  FunctionPass * createARMSilhouetteSFI(void) {
+    return new ARMSilhouetteSFI();
+  }
+}
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteSFI.h b/llvm/lib/Target/ARM/ARMSilhouetteSFI.h
new file mode 100644
index 00000000000..c0613306a7e
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteSFI.h
@@ -0,0 +1,53 @@
+//===-- ARMSilhouetteSFI - Software Fault Isolation on stores -------------===//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass applies bit-masking on addresses that the generated code stores
+// into, either selectively (applying to only heavyweight stores) or entirely.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#ifndef ARM_SILHOUETTE_SFI
+#define ARM_SILHOUETTE_SFI
+
+#include "ARMSilhouetteInstrumentor.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+
+namespace llvm {
+
+  enum SilhouetteSFIOption {
+    // No SFI
+    NoSFI,
+    // Selective SFI
+    SelSFI,
+    // Full SFI
+    FullSFI,
+  };
+
+  // The SFI masks for t2BICri
+  static const uint32_t SFI_MASK  = 0xc0000000u;
+  static const uint32_t SFI_MASK2 = 0x00800000u;
+
+  struct ARMSilhouetteSFI
+      : public MachineFunctionPass, ARMSilhouetteInstrumentor {
+    // pass identifier variable
+    static char ID;
+
+    ARMSilhouetteSFI();
+
+    virtual StringRef getPassName() const override;
+
+    virtual bool runOnMachineFunction(MachineFunction & MF) override;
+  };
+
+  FunctionPass *createARMSilhouetteSFI(void);
+
+}
+
+#endif
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteSTR2STRT.cpp b/llvm/lib/Target/ARM/ARMSilhouetteSTR2STRT.cpp
new file mode 100644
index 00000000000..27a042c1f71
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteSTR2STRT.cpp
@@ -0,0 +1,1646 @@
+//===-- ARMSilhouetteSTR2STRT - Store to Unprivileged Store convertion-----===//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass converts all regular store instructions to the unprivileged store
+// instructions.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#include "ARM.h"
+#include "ARMSilhouetteConvertFuncList.h"
+#include "ARMSilhouetteSFI.h"
+#include "ARMSilhouetteSTR2STRT.h"
+#include "ARMTargetMachine.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/FileSystem.h"
+
+#include <deque>
+
+using namespace llvm;
+
+extern SilhouetteSFIOption SilhouetteSFI;
+
+char ARMSilhouetteSTR2STRT::ID = 0;
+
+static DebugLoc DL;
+
+ARMSilhouetteSTR2STRT::ARMSilhouetteSTR2STRT()
+    : MachineFunctionPass(ID) {
+}
+
+StringRef
+ARMSilhouetteSTR2STRT::getPassName() const {
+  return "ARM Silhouette Store Promotion Pass";
+}
+
+//
+// Function: backupRegisters()
+//
+// Description:
+//   This function backs up at most 2 core registers onto the stack and puts
+//   the new instruction(s) at the end of a deque.  Either register or both
+//   (which does't quite make sense, though) can be left out by passing
+//   ARM::NoRegister.  There is no ordering requirement between the two
+//   registers.
+//
+// Inputs:
+//   MI    - A reference to the store instruction before which to insert new
+//           instructions.
+//   Reg1  - The first register to back up.
+//   Reg2  - The second register to back up.
+//   Insts - A reference to a deque that contains new instructions.
+//
+static void
+backupRegisters(MachineInstr & MI, unsigned Reg1, unsigned Reg2,
+                std::deque<MachineInstr *> & Insts) {
+  MachineFunction & MF = *MI.getMF();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  unsigned PredReg;
+  ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+  unsigned offset = 0;
+  unsigned numRegs = 0;
+  if (Reg1 != ARM::NoRegister) {
+    ++numRegs;
+  }
+  if (Reg2 != ARM::NoRegister) {
+    ++numRegs;
+  }
+
+  //
+  // Build the following instruction sequence:
+  //
+  // sub  sp, #offset
+  // strt reg1, [sp, #0]
+  // strt reg2, [sp, #4]
+  //
+  if (numRegs != 0) {
+    Insts.push_back(BuildMI(MF, DL, TII->get(ARM::tSUBspi), ARM::SP)
+                    .addReg(ARM::SP)
+                    .addImm(numRegs)
+                    .add(predOps(Pred, PredReg)));
+    if (Reg1 != ARM::NoRegister) {
+      Insts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                      .addReg(Reg1)
+                      .addReg(ARM::SP)
+                      .addImm(offset));
+      offset += 4;
+    }
+    if (Reg2 != ARM::NoRegister) {
+      Insts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                      .addReg(Reg2)
+                      .addReg(ARM::SP)
+                      .addImm(offset));
+      offset += 4;
+    }
+  }
+}
+
+//
+// Function: restoreRegisters()
+//
+// Description:
+//   This function restores at most 2 core registers from the stack and puts
+//   the new instruction(s) at the end of a deque.  Either register or both
+//   (which does't quite make sense, though) can be left out by passing
+//   ARM::NoRegister.  The two registers should be lo registers (R0 - R7), and
+//   the first one should be stricly smaller than the second one.
+//
+// Inputs:
+//   MI    - A reference to the store instruction before which to insert new
+//           instructions.
+//   Reg1  - The first register to restore.
+//   Reg2  - The second register to restore.
+//   Insts - A reference to a deque that contains new instructions.
+//
+static void
+restoreRegisters(MachineInstr & MI, unsigned Reg1, unsigned Reg2,
+                 std::deque<MachineInstr *> & Insts) {
+  assert(((Reg1 >= ARM::R0 && Reg1 < ARM::R8) || Reg1 == ARM::NoRegister) &&
+         "Cannot restore a hi register using T1 POP!");
+  assert(((Reg2 >= ARM::R0 && Reg2 < ARM::R8) || Reg2 == ARM::NoRegister) &&
+         "Cannot restore a hi register using T1 POP!");
+  if (Reg1 != ARM::NoRegister && Reg2 != ARM::NoRegister) {
+    assert(Reg1 < Reg2 && "Invalid register order for T1 POP!");
+  }
+
+  MachineFunction & MF = *MI.getMF();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  unsigned PredReg;
+  ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+  // Build a POP that pops out the register content from stack
+  if (Reg1 != ARM::NoRegister || Reg2 != ARM::NoRegister) {
+    MachineInstrBuilder MIB = BuildMI(MF, DL, TII->get(ARM::tPOP))
+                              .add(predOps(Pred, PredReg));
+    if (Reg1 != ARM::NoRegister) {
+      MIB.addReg(Reg1);
+    }
+    if (Reg2 != ARM::NoRegister) {
+      MIB.addReg(Reg2);
+    }
+    Insts.push_back(MIB.getInstr());
+  }
+}
+
+//
+// Function: handleSPWithUncommonImm()
+//
+// Description:
+//   This function takes care of cases where the base register of a store is SP
+//   and the immediate offset is not aligned by 4 or greater than 255.
+//
+// Inputs:
+//   MI       - A reference to a store instruction before which to insert new
+//              instructions.
+//   SrcReg   - The source register of the store.
+//   Imm      - The immediate offset of the store.
+//   strOpc   - The opcode of the new unprivileged store.
+//   Insts    - A reference to a deque that contains new instructions.
+//   FreeRegs - A reference to a deque that contains free registers before MI.
+//   SrcReg2  - The second register of the store in case this is a double word
+//              store.
+//
+static void
+handleSPWithUncommonImm(MachineInstr & MI, unsigned SrcReg, int64_t Imm,
+                        unsigned strOpc, std::deque<MachineInstr *> & Insts,
+                        std::deque<unsigned> & FreeRegs,
+                        unsigned SrcReg2 = ARM::NoRegister) {
+  MachineFunction & MF = *MI.getMF();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  unsigned PredReg;
+  ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+  // First try to find a free register
+  unsigned ScratchReg = ARM::NoRegister;
+  bool needSpill = true;
+  for (unsigned Reg : FreeRegs) {
+    if (Reg != SrcReg && Reg != SrcReg2) {
+      ScratchReg = Reg;
+      needSpill = false;
+      break;
+    }
+  }
+
+  if (needSpill) {
+    errs() << "[SP] Unable to find a free register for SP in " << MI;
+    // Find a register to spill
+    ScratchReg = ARM::R4;
+    while (ScratchReg == SrcReg || ScratchReg == SrcReg2) ScratchReg++;
+    backupRegisters(MI, ScratchReg, ARM::NoRegister, Insts);
+    Imm += 4; // Compensate for SP decrement
+  }
+
+  // Add SP with the uncommon immediate to the scratch register
+  unsigned addOpc = Imm < 0 ? ARM::t2SUBri12 : ARM::t2ADDri12;
+  Insts.push_back(BuildMI(MF, DL, TII->get(addOpc), ScratchReg)
+                  .addReg(ARM::SP)
+                  .addImm(Imm < 0 ? -Imm : Imm)
+                  .add(predOps(Pred, PredReg)));
+
+  // Do store
+  Insts.push_back(BuildMI(MF, DL, TII->get(strOpc))
+                  .addReg(SrcReg)
+                  .addReg(ScratchReg)
+                  .addImm(0));
+  if (SrcReg2 != ARM::NoRegister) {
+    Insts.push_back(BuildMI(MF, DL, TII->get(strOpc))
+                    .addReg(SrcReg2)
+                    .addReg(ScratchReg)
+                    .addImm(4));
+  }
+
+  if (needSpill) {
+    // Restore the scratch register from the stack
+    restoreRegisters(MI, ScratchReg, ARM::NoRegister, Insts);
+  }
+}
+
+//
+// Function: handleSPWithOffsetReg()
+//
+// Description:
+//   This function handles the case where the base register of a Store Register
+//   instruction is SP.  In this case, we cannot put a pair of ADD/SUB around
+//   the store because a hardware interrupt would corrupt the stack if it
+//   happens right after the ADD.
+//
+// Inputs:
+//   MI        - A reference to a store instruction before which to insert new
+//               instructions.
+//   SrcReg    - The source register of the store.
+//   OffserReg - The offset register of the store.
+//   ShiftImm  - The left shift immediate of the store.
+//   strOpc    - The opcode of the new unprivileged store.
+//   Insts     - A reference to a deque that contains new instructions.
+//   FreeRegs  - A reference to a deque that contains free registers before MI.
+//
+static void
+handleSPWithOffsetReg(MachineInstr & MI, unsigned SrcReg, unsigned OffsetReg,
+                      unsigned ShiftImm, unsigned strOpc,
+                      std::deque<MachineInstr *> & Insts,
+                      std::deque<unsigned> & FreeRegs) {
+  MachineFunction & MF = *MI.getMF();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  unsigned PredReg;
+  ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+  // First try to find a free register
+  unsigned ScratchReg = ARM::NoRegister;
+  bool needSpill = true;
+  for (unsigned Reg : FreeRegs) {
+    if (Reg != SrcReg && Reg != OffsetReg) {
+      ScratchReg = Reg;
+      needSpill = false;
+      break;
+    }
+  }
+
+  if (needSpill) {
+    errs() << "[SP] Unable to find a free register for SP in " << MI;
+    // Save a scratch register onto the stack.
+    ScratchReg = ARM::R0;
+    while (ScratchReg == SrcReg || ScratchReg == OffsetReg) ScratchReg++;
+    backupRegisters(MI, ScratchReg, ARM::NoRegister, Insts);
+  }
+
+  // Add SP and the offset register to the scratch register.
+  if (ShiftImm > 0) {
+    Insts.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrs), ScratchReg)
+                    .addReg(ARM::SP)
+                    .addReg(OffsetReg)
+                    .addImm(ShiftImm)
+                    .add(predOps(Pred, PredReg))
+                    .add(condCodeOp()));
+  } else {
+    Insts.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrr), ScratchReg)
+                    .addReg(ARM::SP)
+                    .addReg(OffsetReg)
+                    .add(predOps(Pred, PredReg))
+                    .add(condCodeOp()));
+  }
+
+  // If we spiiled a register, we have to compensate the SP decrement by an ADD
+  if (needSpill) {
+    Insts.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDri12), ScratchReg)
+                    .addReg(ScratchReg)
+                    .addImm(4)
+                    .add(predOps(Pred, PredReg)));
+  }
+
+  // Do the store
+  Insts.push_back(BuildMI(MF, DL, TII->get(strOpc))
+                  .addReg(SrcReg)
+                  .addReg(ScratchReg)
+                  .addImm(0));
+
+  // Restore the scratch register from the stack if we spilled it
+  if (needSpill) {
+    restoreRegisters(MI, ScratchReg, ARM::NoRegister, Insts);
+  }
+}
+
+//
+// Method: runOnMachineFunction()
+//
+// Description:
+//   This method is called when the PassManager wants this pass to transform
+//   the specified MachineFunction.  This method deletes all the regular store
+//   instructions and inserts unprivileged store instructions.
+//
+// Inputs:
+//   MF - A reference to the MachineFunction to transform.
+//
+// Outputs:
+//   MF - The transformed MachineFunction.
+//
+// Return value:
+//   true  - The MachineFunction was transformed.
+//   false - The MachineFunction was not transformed.
+//
+bool
+ARMSilhouetteSTR2STRT::runOnMachineFunction(MachineFunction & MF) {
+#if 1
+  // Skip certain functions
+  if (funcBlacklist.find(MF.getName()) != funcBlacklist.end()) {
+    return false;
+  }
+  // Skip privileged functions in FreeRTOS
+  if (MF.getFunction().getSection().equals("privileged_functions")){
+    errs() << "Privileged function! skipped\n";
+    return false;
+  }
+#endif
+
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  unsigned long OldCodeSize = getFunctionCodeSize(MF);
+
+  // Iterate over all machine instructions to find stores
+  std::deque<MachineInstr *> Stores;
+  for (MachineBasicBlock & MBB : MF) {
+    for (MachineInstr & MI : MBB) {
+      if (!MI.mayStore() || MI.getFlag(MachineInstr::ShadowStack)) {
+        continue;
+      }
+
+      switch (MI.getOpcode()) {
+      // Store word immediate
+      case ARM::tSTRi:       // A7.7.158 Encoding T1
+      case ARM::tSTRspi:     // A7.7.158 Encoding T2
+      case ARM::t2STRi12:    // A7.7.158 Encoding T3
+      case ARM::t2STRi8:     // A7.7.158 Encoding T4; no write-back
+      // Store halfword immediate
+      case ARM::tSTRHi:      // A7.7.167 Encoding T1
+      case ARM::t2STRHi12:   // A7.7.167 Encoding T2
+      case ARM::t2STRHi8:    // A7.7.167 Encoding T3; no write-back
+      // Store byte immediate
+      case ARM::tSTRBi:      // A7.7.160 Encoding T1
+      case ARM::t2STRBi12:   // A7.7.160 Encoding T2
+      case ARM::t2STRBi8:    // A7.7.160 Encoding T3; no write-back
+      // Store word with write-back
+      case ARM::t2STR_PRE:   // A7.7.158 Encoding T4; pre-indexed
+      case ARM::t2STR_POST:  // A7.7.158 Encoding T4; post-indexed
+      // Store halfword with write-back
+      case ARM::t2STRH_PRE:  // A7.7.167 Encoding T3; pre-indexed
+      case ARM::t2STRH_POST: // A7.7.167 Encoding T3; post-indexed
+      // Store byte with write-back
+      case ARM::t2STRB_PRE:  // A7.7.160 Encoding T3; pre-indexed
+      case ARM::t2STRB_POST: // A7.7.160 Encoding T3; post-indexed
+      // Store word register
+      case ARM::tSTRr:       // A7.7.159 Encoding T1
+      case ARM::t2STRs:      // A7.7.159 Encoding T2
+      // Store halfword register
+      case ARM::tSTRHr:      // A7.7.168 Encoding T1
+      case ARM::t2STRHs:     // A7.7.168 Encoding T2
+      // Store byte register
+      case ARM::tSTRBr:      // A7.7.161 Encoding T1
+      case ARM::t2STRBs:     // A7.7.161 Encoding T2
+      // Store dual
+      case ARM::t2STRDi8:    // A7.7.163 Encoding T1; no write-back
+      case ARM::t2STRD_PRE:  // A7.7.163 Encoding T1; pre-indexed
+      case ARM::t2STRD_POST: // A7.7.163 Encoding T1; post-indexed
+        // Lightweight stores; leave them as is only if we are using full SFI
+        if (SilhouetteSFI != FullSFI) {
+          Stores.push_back(&MI);
+        }
+        break;
+
+      // Floating-point store
+      case ARM::VSTRD:       // A7.7.256 Encoding T1
+      case ARM::VSTRS:       // A7.7.256 Encoding T2
+      // Store multiple
+      case ARM::tSTMIA_UPD:  // A7.7.156 Encoding T1
+      case ARM::t2STMIA:     // A7.7.156 Encoding T2; no write-back
+      case ARM::t2STMIA_UPD: // A7.7.156 Encoding T2; with write-back
+      case ARM::t2STMDB:     // A7.7.157 Encoding T1; no write-back
+      case ARM::t2STMDB_UPD: // A7.7.157 Encoding T1; with write-back
+      // Push
+      case ARM::tPUSH:       // A7.7.99 Encoding T1
+      // Floating-point store multiple
+      case ARM::VSTMDIA:     // A7.7.255 Encoding T1; increment after; no write-back
+      case ARM::VSTMDIA_UPD: // A7.7.255 Encoding T1; increment after; with write-back
+      case ARM::VSTMDDB_UPD: // A7.7.255 Encoding T1; decrement before; with write-back
+      case ARM::VSTMSIA:     // A7.7.255 Encoding T2; increment after; no write-back
+      case ARM::VSTMSIA_UPD: // A7.7.255 Encoding T2; increment after; with write-back
+      case ARM::VSTMSDB_UPD: // A7.7.255 Encoding T2; decrement before; with write-back
+        // Heavyweight stores; instrument them only if we are not using SFI
+        if (SilhouetteSFI == NoSFI) {
+          Stores.push_back(&MI);
+        }
+        break;
+
+      case ARM::INLINEASM:
+        break;
+
+      default:
+        errs() << "[SP] Unidentified store: " << MI;
+        break;
+      }
+    }
+  }
+
+  // Instrument each different type of stores
+  for (MachineInstr * Store : Stores) {
+    MachineInstr & MI = *Store;
+
+    unsigned PredReg;
+    ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+    unsigned BaseReg, OffsetReg;
+    unsigned SrcReg, SrcReg2;
+    unsigned ScratchReg, ScratchReg2;
+    int64_t Imm, Imm2;
+    std::deque<unsigned> RegList;
+    std::deque<unsigned> FreeRegs;
+
+    std::deque<MachineInstr *> NewInsts;
+    switch (MI.getOpcode()) {
+    //================================================================
+    // Store word immediate.
+    //================================================================
+
+    // A7.7.158 Encoding T1: STR<c> <Rt>,[<Rn>{,#<imm5>}]
+    case ARM::tSTRi:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm() << 2; // Not ZeroExtend(imm5:'00', 32) yet
+      // imm5:'00' is small enough to be encoded in STRT
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(Imm));
+      break;
+
+    // A7.7.158 Encoding T2: STR<c> <Rt>,[SP,#<imm8>]
+    case ARM::tSTRspi:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm() << 2; // Not ZeroExtend(imm8:'00', 32) yet
+      // imm8:'00' might go beyond 255; we surround STRT with ADD/SUB
+      if (Imm > 255) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRT, NewInsts,
+                                FreeRegs);
+        break;
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(Imm));
+      break;
+
+    // A7.7.158 Encoding T3: STR<c>.W <Rt>,[<Rn>,#<imm12>]
+    case ARM::t2STRi12:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm();
+      // imm12 might go beyond 255.
+      if (BaseReg == ARM::SP && Imm > 255) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRT, NewInsts,
+                                FreeRegs);
+        break;
+      }
+      if (Imm > 255) {
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(Imm > 255 ? 0 : Imm));
+      if (Imm > 255) {
+        subtractImmediateFromRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      break;
+
+    // A7.7.158 Encoding T4: STR<c> <Rt>,[<Rn>,#-<imm8>]
+    case ARM::t2STRi8:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm();
+      if (BaseReg == ARM::SP && Imm % 4 != 0) {
+        // This case shouldn't happen as this store stores a word.
+        // What we do here is a "just in case".
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRT, NewInsts,
+                                FreeRegs);
+        break;
+      }
+      // -imm8 might be 0 (-256 counting the 'U' bit), in which case we don't
+      // build SUB/ADD
+      if (Imm != -256) {
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      if (Imm != -256) {
+        subtractImmediateFromRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      break;
+
+    //================================================================
+    // Store halfword immediate.
+    //================================================================
+
+    // A7.7.167 Encoding T1: STRH<c> <Rt>,[<Rn>{,#<imm5>}]
+    case ARM::tSTRHi:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm() << 1; // Not ZeroExtend(imm5:'0', 32) yet
+      // imm5:'0' is small enough to be encoded in STRHT
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRHT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(Imm));
+      break;
+
+    // A7.7.167 Encoding T2: STRH<c>.W <Rt>,[<Rn>,#<imm12>]
+    case ARM::t2STRHi12:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm();
+      // Special case.
+      if (BaseReg == ARM::SP && Imm > 255) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRHT, NewInsts,
+                                FreeRegs);
+        break;
+      }
+      // imm12 might go beyond 255.
+      if (Imm > 255) {
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRHT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(Imm > 255 ? 0 : Imm));
+      if (Imm > 255) {
+        subtractImmediateFromRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      break;
+
+    // A7.7.167 Encoding T3: STRH<c> <Rt>,[<Rn>,#-<imm8>]
+    case ARM::t2STRHi8:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm();
+      // SP has to be 4 byte aligned; if the easy ways won't apply,
+      // special-case it
+      if (BaseReg == ARM::SP && Imm % 4 != 0) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRHT, NewInsts,
+                                FreeRegs);
+        break;
+      }
+      // -imm8 might be 0 (-256 counting the 'U' bit), in which case we don't
+      // build SUB/ADD
+      if (Imm != -256) {
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRHT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      if (Imm != -256) {
+        subtractImmediateFromRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      break;
+
+    //================================================================
+    // Store byte immediate.
+    //================================================================
+
+    // A7.7.160 Encoding T1: STRB<c> <Rt>,[<Rn>{,#<imm5>}]
+    case ARM::tSTRBi:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm();
+      // imm5 is small enough to be encoded in STRBT
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRBT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(Imm));
+      break;
+
+    // A7.7.160 Encoding T2: STRB<c>.W <Rt>,[<Rn>,#<imm12>]
+    case ARM::t2STRBi12:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm();
+      if (BaseReg == ARM::SP && Imm > 255) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRBT, NewInsts,
+                                FreeRegs);
+        break;
+      }
+      // imm12 might go beyond 255; surround STRBT with ADD/SUB
+      if (Imm > 255) {
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRBT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(Imm > 255 ? 0 : Imm));
+      if (Imm > 255) {
+        subtractImmediateFromRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      break;
+
+    // A7.7.160 Encoding T3: STRB<c> <Rt>,[<Rn>,#-<imm8>]
+    case ARM::t2STRBi8:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(2).getImm();
+      // SP has to be 4 byte aligned; if the easy ways won't apply,
+      // special-case it
+      if (BaseReg == ARM::SP && Imm % 4 != 0) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRBT, NewInsts,
+                                FreeRegs);
+        break;
+      }
+      // -imm8 might be 0 (-256 counting the 'U' bit), in which case we don't
+      // build SUB/ADD
+      if (Imm != -256) {
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRBT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      if (Imm != -256) {
+        subtractImmediateFromRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      break;
+
+    //================================================================
+    // Store word with write-back.
+    //================================================================
+
+    // A7.7.158 Encoding T4: STR<c> <Rt>,[<Rn>,#+/-<imm8>]!
+    case ARM::t2STR_PRE:
+      BaseReg = MI.getOperand(0).getReg();
+      SrcReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(3).getImm();
+      // Pre-indexed: first ADD/SUB then STRT
+      if (BaseReg == ARM::SP && Imm > 0) {
+        // When the base register is SP, we need to specially handle it;
+        // otherwise we might encounter an error if a hardware interrupt
+        // kicks in after the ADD/SUB operation.
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRT, NewInsts,
+                                FreeRegs);
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+        break;
+      }
+      addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      break;
+
+    // A7.7.158 Encoding T4: STR<c> <Rt>,[<Rn>],#+/-<imm8>
+    case ARM::t2STR_POST:
+      BaseReg = MI.getOperand(0).getReg();
+      SrcReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(3).getImm();
+      // Post-indexed: first STRT then ADD/SUB
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      break;
+
+    //================================================================
+    // Store halfword with write-back.
+    //================================================================
+
+    // A7.7.167 Encoding T3: STRH<c> <Rt>,[<Rn>,#+/-<imm8>]!
+    case ARM::t2STRH_PRE:
+      BaseReg = MI.getOperand(0).getReg();
+      SrcReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(3).getImm();
+      // Pre-indexed: first ADD/SUB then STRHT
+      if (BaseReg == ARM::SP && Imm > 0) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRHT, NewInsts,
+                                FreeRegs);
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+        break;
+      }
+      addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRHT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      break;
+
+    // A7.7.167 Encoding T3: STRH<c> <Rt>,[<Rn>],#+/-<imm8>
+    case ARM::t2STRH_POST:
+      BaseReg = MI.getOperand(0).getReg();
+      SrcReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(3).getImm();
+      // Post-indexed: first STRHT then ADD/SUB
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRHT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      break;
+
+    //================================================================
+    // Store byte with write-back.
+    //================================================================
+
+    // A7.7.160 Encoding T3: STRB<c> <Rt>,[<Rn>,#+/-<imm8>]!
+    case ARM::t2STRB_PRE:
+      BaseReg = MI.getOperand(0).getReg();
+      SrcReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(3).getImm();
+      // Pre-indexed: first ADD/SUB then STRBT
+      if (BaseReg == ARM::SP && Imm > 0) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRBT, NewInsts,
+                                FreeRegs);
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+        break;
+      }
+      addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRBT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      break;
+
+    // A7.7.160 Encoding T3: STRB<c> <Rt>,[<Rn>],#+/-<imm8>
+    case ARM::t2STRB_POST:
+      BaseReg = MI.getOperand(0).getReg();
+      SrcReg = MI.getOperand(1).getReg();
+      Imm = MI.getOperand(3).getImm();
+      // Post-indexed: first STRBT then ADD/SUB
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRBT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      break;
+
+    //================================================================
+    // Store word register.
+    //================================================================
+
+    // A7.7.159 Encoding T1: STR<c> <Rt>,[<Rn>,<Rm>]
+    case ARM::tSTRr:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      OffsetReg = MI.getOperand(2).getReg();
+      // Add offset to base, do store, and subtract offset from base
+      if (BaseReg == ARM::SP) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithOffsetReg(MI, SrcReg, OffsetReg, 0, ARM::t2STRT,
+                              NewInsts, FreeRegs);
+        break;
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrr), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2SUBrr), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      break;
+
+    // A7.7.159 Encoding T2: STR<c>.W <Rt>,[<Rn>,<Rm>{,LSL #<imm2>}]
+    case ARM::t2STRs:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      OffsetReg = MI.getOperand(2).getReg();
+      Imm = ARM_AM::getSORegOpc(ARM_AM::lsl, MI.getOperand(3).getImm());
+      // Add offset with LSL to base, do store, and subtract offset with LSL
+      // from base
+      if (BaseReg == ARM::SP) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithOffsetReg(MI, SrcReg, OffsetReg, Imm, ARM::t2STRT,
+                              NewInsts, FreeRegs);
+        break;
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrs), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .addImm(Imm)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2SUBrs), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .addImm(Imm)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      break;
+
+    //================================================================
+    // Store halfword register.
+    //================================================================
+
+    // A7.7.168 Encoding T1: STRH<c> <Rt>,[<Rn>,<Rm>]
+    case ARM::tSTRHr:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      OffsetReg = MI.getOperand(2).getReg();
+      if (BaseReg == ARM::SP) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithOffsetReg(MI, SrcReg, OffsetReg, 0, ARM::t2STRHT,
+                              NewInsts, FreeRegs);
+        break;
+      }
+      // Add offset to base, do store, and subtract offset from base
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrr), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRHT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2SUBrr), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      break;
+
+    // A7.7.168 Encoding T2: STRH<c>.W <Rt>,[<Rn>,<Rm>{,LSL #<imm2>}]
+    case ARM::t2STRHs:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      OffsetReg = MI.getOperand(2).getReg();
+      Imm = ARM_AM::getSORegOpc(ARM_AM::lsl, MI.getOperand(3).getImm());
+      if (BaseReg == ARM::SP) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithOffsetReg(MI, SrcReg, OffsetReg, Imm, ARM::t2STRHT,
+                              NewInsts, FreeRegs);
+        break;
+      }
+      // Add offset with LSL to base, do store, and subtract offset with LSL
+      // from base
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrs), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .addImm(Imm)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRHT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2SUBrs), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .addImm(Imm)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      break;
+
+    //================================================================
+    // Store byte register.
+    //================================================================
+
+    // A7.7.161 Encoding T1: STRB<c> <Rt>,[<Rn>,<Rm>]
+    case ARM::tSTRBr:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      OffsetReg = MI.getOperand(2).getReg();
+      if (BaseReg == ARM::SP) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithOffsetReg(MI, SrcReg, OffsetReg, 0, ARM::t2STRBT,
+                              NewInsts, FreeRegs);
+        break;
+      }
+      // Add offset to base, do store, and subtract offset from base
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrr), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRBT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2SUBrr), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      break;
+
+    // A7.7.161 Encoding T2: STRB<c>.W <Rt>,[<Rn>,<Rm>{,LSL #<imm2>}]
+    case ARM::t2STRBs:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      OffsetReg = MI.getOperand(2).getReg();
+      Imm = ARM_AM::getSORegOpc(ARM_AM::lsl, MI.getOperand(3).getImm());
+      if (BaseReg == ARM::SP) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithOffsetReg(MI, SrcReg, OffsetReg, Imm, ARM::t2STRBT,
+                              NewInsts, FreeRegs);
+        break;
+      }
+      // Add offset with LSL to base, do store, and subtract offset with LSL
+      // from base
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2ADDrs), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .addImm(Imm)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRBT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2SUBrs), BaseReg)
+                         .addReg(BaseReg)
+                         .addReg(OffsetReg)
+                         .addImm(Imm)
+                         .add(predOps(Pred, PredReg))
+                         .add(condCodeOp()));
+      break;
+
+    //================================================================
+    // Store dual immediate.
+    //================================================================
+
+    // A7.7.163 Encoding T1: STRD<c> <Rt>,<Rt2>,[<Rn>{,#+/-<imm8>}]
+    case ARM::t2STRDi8:
+      SrcReg = MI.getOperand(0).getReg();
+      SrcReg2 = MI.getOperand(1).getReg();
+      BaseReg = MI.getOperand(2).getReg();
+      Imm = MI.getOperand(3).getImm(); // Already ZeroExtend(imm8:'00', 32)
+      Imm2 = Imm;
+      // 251 comes from the fact that the immediate of the second STRT cannot
+      // go beyond 255.
+      if (BaseReg == ARM::SP && Imm > 251) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRT, NewInsts,
+                                FreeRegs, SrcReg2);
+        break;
+      }
+      // When Imm is negative, add a pair of add/sub to handle this store.
+      if (Imm < 0 || Imm > 251) {
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+        Imm2 = 0;
+      }
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(Imm2));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg2)
+                         .addReg(BaseReg)
+                         .addImm(Imm2 + 4));
+      if (Imm < 0 || Imm > 251) {
+        subtractImmediateFromRegister(MI, BaseReg, Imm, NewInsts);
+      }
+      break;
+
+    //================================================================
+    // Store dual immediate with write-back.
+    //================================================================
+
+    // A7.7.163 Encoding T1: STRD<c> <Rt>,<Rt2>,[<Rn>,#+/-<imm8>]!
+    case ARM::t2STRD_PRE:
+      BaseReg = MI.getOperand(0).getReg();
+      SrcReg = MI.getOperand(1).getReg();
+      SrcReg2 = MI.getOperand(2).getReg();
+      Imm = MI.getOperand(4).getImm(); // Already ZeroExtend(imm8:'00', 32)
+      if (BaseReg == ARM::SP && Imm > 0) {
+        FreeRegs = findFreeRegisters(MI);
+        handleSPWithUncommonImm(MI, SrcReg, Imm, ARM::t2STRT, NewInsts,
+                                FreeRegs, SrcReg2);
+        addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+        break;
+      }
+      // Pre-indexed: first ADD/SUB then 2 STRBTs
+      addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg2)
+                         .addReg(BaseReg)
+                         .addImm(4));
+      break;
+
+    // A7.7.163 Encoding T1: STRD<c> <Rt>,<Rt2>,[<Rn>],#+/-<imm8>
+    case ARM::t2STRD_POST:
+      BaseReg = MI.getOperand(0).getReg();
+      SrcReg = MI.getOperand(1).getReg();
+      SrcReg2 = MI.getOperand(2).getReg();
+      Imm = MI.getOperand(4).getImm(); // Already ZeroExtend(imm8:'00', 32)
+      // Post-indexed: first 2 STRBTs then ADD/SUB
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg)
+                         .addReg(BaseReg)
+                         .addImm(0));
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                         .addReg(SrcReg2)
+                         .addReg(BaseReg)
+                         .addImm(4));
+      addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+      break;
+
+    //================================================================
+    // Floating-point store.
+    //================================================================
+
+    // A7.7.256 Encoding T1: VSTR<c> <Dd>,[<Rn>{,#+/-<imm8>}]
+    case ARM::VSTRD:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      // Not ZeroExtend(imm8:'00', 32) yet
+      Imm = ARM_AM::getAM5Offset(MI.getOperand(2).getImm()) << 2;
+      if (ARM_AM::getAM5Op(MI.getOperand(2).getImm()) == ARM_AM::AddrOpc::sub) {
+        Imm = -Imm;
+      }
+      // First try to find 2 free registers; if we couldn't find enough
+      // registers, then resort to register spills
+      FreeRegs = findFreeRegisters(MI);
+      if (FreeRegs.size() >= 2) {
+        ScratchReg = FreeRegs[0];
+        ScratchReg2 = FreeRegs[1];
+      } else {
+        errs() << "[SP] Unable to find free registers for " << MI;
+        // Saving 2 scratch registers onto the stack causes SP to decrement by
+        // 8.  If the base register is SP, we compensate it by increasing the
+        // immediate by the same amount.
+        if (BaseReg == ARM::SP) {
+          Imm += 8;
+        }
+        // Pick 2 core registers as scratch registers, because STRT can only
+        // encode core registers
+        ScratchReg = BaseReg == ARM::R0 ? ARM::R1 : ARM::R0;
+        ScratchReg2 = BaseReg == ARM::R2 ? ARM::R3 : ARM::R2;
+        // Back up scratch registers onto the stack
+        backupRegisters(MI, ScratchReg, ScratchReg2, NewInsts);
+      }
+      Imm2 = Imm;
+      // Move from the source register to 2 scratch registers
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::VMOVRRD))
+                         .addReg(ScratchReg)
+                         .addReg(ScratchReg2)
+                         .addReg(SrcReg)
+                         .add(predOps(Pred, PredReg)));
+      if (BaseReg == ARM::SP && Imm > 251) {
+        handleSPWithUncommonImm(MI, ScratchReg, Imm, ARM::t2STRT, NewInsts,
+                                FreeRegs, ScratchReg2);
+      } else {
+        // imm8 could be either negative or beyond 251, in which cases we
+        // surround 2 STRTs with ADD/SUB.  251 comes from the fact that the
+        // immediate of the second STRT cannot go beyond 255.
+        if (Imm < 0 || Imm > 251) {
+          addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+          Imm2 = 0;
+        }
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg)
+                           .addReg(BaseReg)
+                           .addImm(Imm2));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg2)
+                           .addReg(BaseReg)
+                           .addImm(Imm2 + 4));
+        if (Imm < 0 || Imm > 251) {
+          subtractImmediateFromRegister(MI, BaseReg, Imm, NewInsts);
+        }
+      }
+      if (FreeRegs.size() < 2) {
+        // Restore scratch registers from the stack
+        restoreRegisters(MI, ScratchReg, ScratchReg2, NewInsts);
+      }
+      break;
+
+    // A7.7.256 Encoding T2: VSTR<c> <Sd>,[<Rn>{,#+/-<imm8>}]
+    case ARM::VSTRS:
+      SrcReg = MI.getOperand(0).getReg();
+      BaseReg = MI.getOperand(1).getReg();
+      // Not ZeroExtend(imm8:'00', 32) yet
+      Imm = ARM_AM::getAM5Offset(MI.getOperand(2).getImm()) << 2;
+      if (ARM_AM::getAM5Op(MI.getOperand(2).getImm()) == ARM_AM::AddrOpc::sub) {
+        Imm = -Imm;
+      }
+      // First try to find a free register; if we couldn't find one, then
+      // resort to register spill
+      FreeRegs = findFreeRegisters(MI);
+      if (!FreeRegs.empty()) {
+        ScratchReg = FreeRegs[0];
+      } else {
+        errs() << "[SP] Unable to find a free register for " << MI;
+        // Saving a scratch register onto the stack causes SP to decrement by
+        // 4.  If the base register is SP, we compensate it by increasing the
+        // immediate by the same amount.
+        if (BaseReg == ARM::SP) {
+          Imm += 4;
+        }
+        // Pick a core register as a scratch register, because STRT can only
+        // encode core registers
+        ScratchReg = BaseReg == ARM::R0 ? ARM::R1 : ARM::R0;
+        // Back up the scratch register onto the stack
+        backupRegisters(MI, ScratchReg, ARM::NoRegister, NewInsts);
+      }
+      Imm2 = Imm;
+      // Move from the source register to the scratch register
+      NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::VMOVRS), ScratchReg)
+                         .addReg(SrcReg)
+                         .add(predOps(Pred, PredReg)));
+      if (BaseReg == ARM::SP && Imm > 255) {
+        handleSPWithUncommonImm(MI, ScratchReg, Imm, ARM::t2STRT, NewInsts,
+                                FreeRegs);
+      } else {
+        // imm8 could be either negative or beyond 255 (after compensating),
+        // in which cases we surround STRT with ADD/SUB
+        if (Imm < 0 || Imm > 255) {
+          addImmediateToRegister(MI, BaseReg, Imm, NewInsts);
+          Imm2 = 0;
+        }
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg)
+                           .addReg(BaseReg)
+                           .addImm(Imm2));
+        if (Imm < 0 || Imm > 255) {
+          subtractImmediateFromRegister(MI, BaseReg, Imm, NewInsts);
+        }
+      }
+      if (FreeRegs.empty()) {
+        // Restore scratch registers from the stack
+        restoreRegisters(MI, ScratchReg, ARM::NoRegister, NewInsts);
+      }
+      break;
+
+    //================================================================
+    // Store multiple.
+    //================================================================
+
+    // A7.7.156 Encoding T1: STM<c> <Rn>!,<registers>
+    case ARM::tSTMIA_UPD:
+    // A7.7.156 Encoding T2; STM<c>.W <Rn>!,<registers>
+    case ARM::t2STMIA_UPD:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // Build an STRT for each register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(RegList[i])
+                           .addReg(BaseReg)
+                           .addImm(i * 4));
+      }
+      // Increment the base register
+      addImmediateToRegister(MI, BaseReg, RegList.size() * 4, NewInsts);
+      break;
+
+    // A7.7.156 Encoding T2; STM<c>.W <Rn>,<registers>
+    case ARM::t2STMIA:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // Build an STRT for each register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(RegList[i])
+                           .addReg(BaseReg)
+                           .addImm(i * 4));
+      }
+      break;
+
+    // A7.7.157 Encoding T1; STMDB<c> <Rn>,<registers>
+    case ARM::t2STMDB:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // Decrement the base register
+      subtractImmediateFromRegister(MI, BaseReg, RegList.size() * 4, NewInsts);
+      // Build an STRT for each register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(RegList[i])
+                           .addReg(BaseReg)
+                           .addImm(i * 4));
+      }
+      // Restore the incremented base register
+      addImmediateToRegister(MI, BaseReg, RegList.size() * 4, NewInsts);
+      break;
+
+    // A7.7.157 Encoding T1; STMDB<c> <Rn>!,<registers>
+    case ARM::t2STMDB_UPD:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // Decrement the base register
+      subtractImmediateFromRegister(MI, BaseReg, RegList.size() * 4, NewInsts);
+      // Build an STRT for each register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(RegList[i])
+                           .addReg(BaseReg)
+                           .addImm(i * 4));
+      }
+      break;
+
+    //================================================================
+    // Push.
+    //================================================================
+
+    // A7.7.99 Encoding T1: PUSH<c> <registers>
+    case ARM::tPUSH:
+      BaseReg = ARM::SP;
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        MachineOperand & MO = MI.getOperand(i);
+        // PUSH implicitly defines and uses SP, so we exclude them explicitly
+        if (!MO.isImplicit()) {
+          RegList.push_back(MO.getReg());
+        }
+      }
+      // Decrement the base register
+      subtractImmediateFromRegister(MI, BaseReg, RegList.size() * 4, NewInsts);
+      // Build an STRT for each register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(RegList[i])
+                           .addReg(BaseReg)
+                           .addImm(i * 4));
+      }
+      break;
+
+    //================================================================
+    // Floating-point store multiple.
+    //================================================================
+
+    // A7.7.255 Encoding T1: VSTMDIA<c> <Rn>,<list>
+    case ARM::VSTMDIA:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // First try to find 2 free registers; if we couldn't find enough
+      // registers, then resort to register spills
+      FreeRegs = findFreeRegisters(MI);
+      if (FreeRegs.size() >= 2) {
+        ScratchReg = FreeRegs[0];
+        ScratchReg2 = FreeRegs[1];
+      } else {
+        errs() << "[SP] Unable to find free registers for " << MI;
+        // Pick 2 core registers as scratch registers, because STRT can only
+        // encode core registers
+        ScratchReg = BaseReg == ARM::R0 ? ARM::R1 : ARM::R0;
+        ScratchReg2 = BaseReg == ARM::R2 ? ARM::R3 : ARM::R2;
+        // Back up scratch registers onto the stack
+        backupRegisters(MI, ScratchReg, ScratchReg2, NewInsts);
+      }
+      // Build 2 STRTs for each doubleword register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        Imm = i * 8;
+        // Saving 2 scratch registers onto the stack causes SP to decrement by
+        // 8.  If the base register is SP, we compensate it by increasing the
+        // immediate by the same amount.
+        if (BaseReg == ARM::SP && FreeRegs.size() < 2) {
+          Imm += 8;
+        }
+        // Move from the source register to 2 scratch registers
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::VMOVRRD))
+                           .addReg(ScratchReg)
+                           .addReg(ScratchReg2)
+                           .addReg(RegList[i])
+                           .add(predOps(Pred, PredReg)));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg)
+                           .addReg(BaseReg)
+                           .addImm(Imm));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg2)
+                           .addReg(BaseReg)
+                           .addImm(Imm + 4));
+      }
+      if (FreeRegs.size() < 2) {
+        // Restore scratch registers from the stack
+        restoreRegisters(MI, ScratchReg, ScratchReg2, NewInsts);
+      }
+      break;
+
+    // A7.7.255 Encoding T1: VSTMDIA<c> <Rn>!,<list>
+    case ARM::VSTMDIA_UPD:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // First try to find 2 free registers; if we couldn't find enough
+      // registers, then resort to register spills
+      FreeRegs = findFreeRegisters(MI);
+      if (FreeRegs.size() >= 2) {
+        ScratchReg = FreeRegs[0];
+        ScratchReg2 = FreeRegs[1];
+      } else {
+        errs() << "[SP] Unable to find free registers for " << MI;
+        // Pick 2 core registers as scratch registers, because STRT can only
+        // encode core registers
+        ScratchReg = BaseReg == ARM::R0 ? ARM::R1 : ARM::R0;
+        ScratchReg2 = BaseReg == ARM::R2 ? ARM::R3 : ARM::R2;
+        // Back up scratch registers onto the stack
+        backupRegisters(MI, ScratchReg, ScratchReg2, NewInsts);
+      }
+      // Build 2 STRTs for each doubleword register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        Imm = i * 8;
+        // Saving 2 scratch registers onto the stack causes SP to decrement by
+        // 8.  If the base register is SP, we compensate it by increasing the
+        // immediate by the same amount.
+        if (BaseReg == ARM::SP && FreeRegs.size() < 2) {
+          Imm += 8;
+        }
+        // Move from the source register to 2 scratch registers
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::VMOVRRD))
+                           .addReg(ScratchReg)
+                           .addReg(ScratchReg2)
+                           .addReg(RegList[i])
+                           .add(predOps(Pred, PredReg)));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg)
+                           .addReg(BaseReg)
+                           .addImm(Imm));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg2)
+                           .addReg(BaseReg)
+                           .addImm(Imm + 4));
+      }
+      if (FreeRegs.size() < 2) {
+        // Restore scratch registers from the stack
+        restoreRegisters(MI, ScratchReg, ScratchReg2, NewInsts);
+      }
+      // Increment the base register
+      addImmediateToRegister(MI, BaseReg, RegList.size() * 8, NewInsts);
+      break;
+
+    // A7.7.255 Encoding T1: VSTMDDB<c> <Rn>!,<list>
+    case ARM::VSTMDDB_UPD:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // Decrement the base register
+      subtractImmediateFromRegister(MI, BaseReg, RegList.size() * 8, NewInsts);
+      // First try to find 2 free registers; if we couldn't find enough
+      // registers, then resort to register spills
+      FreeRegs = findFreeRegisters(MI);
+      if (FreeRegs.size() >= 2) {
+        ScratchReg = FreeRegs[0];
+        ScratchReg2 = FreeRegs[1];
+      } else {
+        errs() << "[SP] Unable to find free registers for " << MI;
+        // Pick 2 core registers as scratch registers, because STRT can only
+        // encode core registers
+        ScratchReg = BaseReg == ARM::R0 ? ARM::R1 : ARM::R0;
+        ScratchReg2 = BaseReg == ARM::R2 ? ARM::R3 : ARM::R2;
+        // Back up scratch registers onto the stack
+        backupRegisters(MI, ScratchReg, ScratchReg2, NewInsts);
+      }
+      // Build 2 STRTs for each doubleword register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        Imm = i * 8;
+        // Saving 2 scratch registers onto the stack causes SP to decrement by
+        // 8.  If the base register is SP, we compensate it by increasing the
+        // immediate by the same amount.
+        if (BaseReg == ARM::SP && FreeRegs.size() < 2) {
+          Imm += 8;
+        }
+        // Move from the source register to 2 scratch registers
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::VMOVRRD))
+                           .addReg(ScratchReg)
+                           .addReg(ScratchReg2)
+                           .addReg(RegList[i])
+                           .add(predOps(Pred, PredReg)));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg)
+                           .addReg(BaseReg)
+                           .addImm(Imm));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg2)
+                           .addReg(BaseReg)
+                           .addImm(Imm + 4));
+      }
+      if (FreeRegs.size() < 2) {
+        // Restore scratch registers from the stack
+        restoreRegisters(MI, ScratchReg, ScratchReg2, NewInsts);
+      }
+      break;
+
+    // A7.7.255 Encoding T2: VSTMSIA<c> <Rn>,<list>
+    case ARM::VSTMSIA:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // First try to find a free register; if we couldn't find one, then
+      // resort to register spill
+      FreeRegs = findFreeRegisters(MI);
+      if (!FreeRegs.empty()) {
+        ScratchReg = FreeRegs[0];
+      } else {
+        errs() << "[SP] Unable to find a free register for " << MI;
+        // Pick a core register as a scratch register, because STRT can only
+        // encode core registers
+        ScratchReg = BaseReg == ARM::R0 ? ARM::R1 : ARM::R0;
+        // Back up the scratch register onto the stack
+        backupRegisters(MI, ScratchReg, ARM::NoRegister, NewInsts);
+      }
+      // Build STRT for each singleword register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        Imm = i * 4;
+        // Saving a scratch register onto the stack causes SP to decrement by
+        // 4.  If the base register is SP, we compensate it by increasing the
+        // immediate by the same amount.
+        if (BaseReg == ARM::SP && FreeRegs.empty()) {
+          Imm += 4;
+        }
+        // Move from the source register to the scratch register
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::VMOVRS), ScratchReg)
+                           .addReg(RegList[i])
+                           .add(predOps(Pred, PredReg)));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg)
+                           .addReg(BaseReg)
+                           .addImm(Imm));
+      }
+      if (FreeRegs.empty()) {
+        // Restore the scratch register from the stack
+        restoreRegisters(MI, ScratchReg, ARM::NoRegister, NewInsts);
+      }
+      break;
+
+    // A7.7.255 Encoding T2: VSTMSIA<c> <Rn>!,<list>
+    case ARM::VSTMSIA_UPD:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // First try to find a free register; if we couldn't find one, then
+      // resort to register spill
+      FreeRegs = findFreeRegisters(MI);
+      if (!FreeRegs.empty()) {
+        ScratchReg = FreeRegs[0];
+      } else {
+        errs() << "[SP] Unable to find a free register for " << MI;
+        // Pick a core register as a scratch register, because STRT can only
+        // encode core registers
+        ScratchReg = BaseReg == ARM::R0 ? ARM::R1 : ARM::R0;
+        // Back up the scratch register onto the stack
+        backupRegisters(MI, ScratchReg, ARM::NoRegister, NewInsts);
+      }
+      // Build STRT for each singleword register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        Imm = i * 4;
+        // Saving a scratch register onto the stack causes SP to decrement by
+        // 4.  If the base register is SP, we compensate it by increasing the
+        // immediate by the same amount.
+        if (BaseReg == ARM::SP && FreeRegs.empty()) {
+          Imm += 4;
+        }
+        // Move from the source register to the scratch register
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::VMOVRS), ScratchReg)
+                           .addReg(RegList[i])
+                           .add(predOps(Pred, PredReg)));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg)
+                           .addReg(BaseReg)
+                           .addImm(Imm));
+      }
+      if (FreeRegs.empty()) {
+        // Restore the scratch register from the stack
+        restoreRegisters(MI, ScratchReg, ARM::NoRegister, NewInsts);
+      }
+      // Increment the base register
+      addImmediateToRegister(MI, BaseReg, RegList.size() * 4, NewInsts);
+      break;
+
+    // A7.7.255 Encoding T2: VSTMSDB<c> <Rn>!,<list>
+    case ARM::VSTMSDB_UPD:
+      BaseReg = MI.getOperand(0).getReg();
+      // Construct a register list
+      for (unsigned i = MI.findFirstPredOperandIdx() + 2;
+           i < MI.getNumOperands();
+           ++i) {
+        RegList.push_back(MI.getOperand(i).getReg());
+      }
+      // Decrement the base register
+      subtractImmediateFromRegister(MI, BaseReg, RegList.size() * 4, NewInsts);
+      // First try to find a free register; if we couldn't find one, then
+      // resort to register spill
+      FreeRegs = findFreeRegisters(MI);
+      if (!FreeRegs.empty()) {
+        ScratchReg = FreeRegs[0];
+      } else {
+        errs() << "[SP] Unable to find a free register for " << MI;
+        // Pick a core register as a scratch register, because STRT can only
+        // encode core registers
+        ScratchReg = BaseReg == ARM::R0 ? ARM::R1 : ARM::R0;
+        // Back up the scratch register onto the stack
+        backupRegisters(MI, ScratchReg, ARM::NoRegister, NewInsts);
+      }
+      // Build STRT for each singleword register in the list
+      for (unsigned i = 0; i < RegList.size(); ++i) {
+        Imm = i * 4;
+        // Saving a scratch register onto the stack causes SP to decrement by
+        // 4.  If the base register is SP, we compensate it by increasing the
+        // immediate by the same amount.
+        if (BaseReg == ARM::SP && FreeRegs.empty()) {
+          Imm += 4;
+        }
+        // Move from the source register to the scratch register
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::VMOVRS), ScratchReg)
+                           .addReg(RegList[i])
+                           .add(predOps(Pred, PredReg)));
+        NewInsts.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                           .addReg(ScratchReg)
+                           .addReg(BaseReg)
+                           .addImm(Imm));
+      }
+      if (FreeRegs.empty()) {
+        // Restore the scratch register from the stack
+        restoreRegisters(MI, ScratchReg, ARM::NoRegister, NewInsts);
+      }
+      break;
+
+    default:
+      llvm_unreachable("Unexpected opcode!");
+    }
+
+    if (!NewInsts.empty()) {
+      insertInstsBefore(MI, NewInsts);
+      removeInst(MI);
+    }
+  }
+
+  unsigned long NewCodeSize = getFunctionCodeSize(MF);
+
+  // Output code size information
+  std::error_code EC;
+  raw_fd_ostream MemStat("./code_size_sp.stat", EC,
+                         sys::fs::OpenFlags::F_Append);
+  MemStat << MF.getName() << ":" << OldCodeSize << ":" << NewCodeSize << "\n";
+
+  return true;
+}
+
+//
+// Create a new pass.
+//
+namespace llvm {
+  FunctionPass * createARMSilhouetteSTR2STRT(void) {
+    return new ARMSilhouetteSTR2STRT();
+  }
+}
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteSTR2STRT.h b/llvm/lib/Target/ARM/ARMSilhouetteSTR2STRT.h
new file mode 100644
index 00000000000..460da52059f
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteSTR2STRT.h
@@ -0,0 +1,39 @@
+//===-- ARMSilhouetteSTR2STRT - Store to Unprivileged Store convertion-----===//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass converts all regular store instructions to the unprivileged store
+// instructions.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#ifndef ARM_SILHOUETTE_STR2STRT
+#define ARM_SILHOUETTE_STR2STRT
+
+#include "ARMSilhouetteInstrumentor.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+
+namespace llvm {
+
+  struct ARMSilhouetteSTR2STRT
+      : public MachineFunctionPass, ARMSilhouetteInstrumentor {
+    // pass identifier variable
+    static char ID;
+
+    ARMSilhouetteSTR2STRT();
+
+    virtual StringRef getPassName() const override;
+
+    virtual bool runOnMachineFunction(MachineFunction & MF) override;
+  };
+
+  FunctionPass *createARMSilhouetteSTR2STRT(void);
+}
+
+#endif
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteShadowStack.cpp b/llvm/lib/Target/ARM/ARMSilhouetteShadowStack.cpp
new file mode 100644
index 00000000000..b6af213033c
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteShadowStack.cpp
@@ -0,0 +1,376 @@
+//===- ARMSilhouetteShadowStack - Modify Prologue/Epilogue for Shadow Stack ==//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass instruments the function prologue/epilogue to save/load the return
+// address from a parallel shadow stack.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#include "ARM.h"
+#include "ARMBaseInstrInfo.h"
+#include "ARMSilhouetteConvertFuncList.h"
+#include "ARMSilhouetteShadowStack.h"
+#include "ARMTargetMachine.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/Support/raw_ostream.h"
+#include "llvm/Support/FileSystem.h"
+
+#include <deque>
+
+using namespace llvm;
+
+extern bool SilhouetteInvert;
+
+char ARMSilhouetteShadowStack::ID = 0;
+
+static DebugLoc DL;
+
+static cl::opt<int>
+ShadowStackOffset("arm-silhouette-shadowstack-offset",
+                  cl::desc("Silhouette shadow stack offset"),
+                  cl::init(14680064), cl::Hidden);
+
+ARMSilhouetteShadowStack::ARMSilhouetteShadowStack()
+    : MachineFunctionPass(ID) {
+  return;
+}
+
+StringRef
+ARMSilhouetteShadowStack::getPassName() const {
+  return "ARM Silhouette Shadow Stack Pass";
+}
+
+//
+// Function: findTailJmp()
+//
+// Description:
+//   This function finds a TAILJMP instruction after a given instruction MI in
+//   the same basic block.
+//
+// Input:
+//   MI - A reference to the instruction after which to find TAILJMP.
+//
+// Return value:
+//   A pointer to TAILJMP if found, nullptr otherwise.
+//
+static MachineInstr *
+findTailJmp(MachineInstr & MI) {
+  MachineInstr * I = MI.getNextNode();
+  while (I != nullptr) {
+    switch (I->getOpcode()) {
+    case ARM::tTAILJMPr:
+    case ARM::tTAILJMPd:
+    case ARM::tTAILJMPdND:
+    case ARM::tBX_RET:  // This is also the case!
+      return I;
+
+    default:
+      I = I->getNextNode();
+      break;
+    }
+  }
+
+  return nullptr;
+}
+
+//
+// Method: setupShadowStack()
+//
+// Description:
+//   This method inserts instructions that store the return address onto the
+//   shadow stack.
+//
+// Input:
+//   MI - A reference to a PUSH instruction before which to insert instructions.
+//
+void
+ARMSilhouetteShadowStack::setupShadowStack(MachineInstr & MI) {
+  MachineFunction & MF = *MI.getMF();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  int offset = ShadowStackOffset;
+
+  unsigned PredReg;
+  ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+  std::deque<MachineInstr *> NewMIs;
+
+  if (offset >= 0 && offset <= 4092 && !SilhouetteInvert) {
+    // Single-instruction shortcut
+    NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRi12))
+                     .addReg(ARM::LR)
+                     .addReg(ARM::SP)
+                     .addImm(offset)
+                     .add(predOps(Pred, PredReg))
+                     .setMIFlag(MachineInstr::ShadowStack));
+  } else {
+    // First encode the shadow stack offset into the scratch register
+    if (ARM_AM::getT2SOImmVal(offset) != -1) {
+      // Use one MOV if the offset can be expressed in Thumb modified constant
+      NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2MOVi), ARM::R12)
+                       .addImm(offset)
+                       .add(predOps(Pred, PredReg))
+                       .add(condCodeOp()) // No 'S' bit
+                       .setMIFlag(MachineInstr::ShadowStack));
+    } else {
+      // Otherwise use MOV/MOVT to load lower/upper 16 bits of the offset
+      NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2MOVi16), ARM::R12)
+                       .addImm(offset & 0xffff)
+                       .add(predOps(Pred, PredReg))
+                       .setMIFlag(MachineInstr::ShadowStack));
+      if ((offset >> 16) != 0) {
+        NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2MOVTi16), ARM::R12)
+                         .addReg(ARM::R12)
+                         .addImm(offset >> 16)
+                         .add(predOps(Pred, PredReg))
+                         .setMIFlag(MachineInstr::ShadowStack));
+      }
+    }
+
+    // Store the return address onto the shadow stack
+    if (SilhouetteInvert) {
+      // Add SP with the offset to the scratch register
+      NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::tADDrSP), ARM::R12)
+                       .addReg(ARM::SP)
+                       .addReg(ARM::R12)
+                       .add(predOps(Pred, PredReg))
+                       .setMIFlag(MachineInstr::ShadowStack));
+      // Generate an STRT to the shadow stack
+      NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRT))
+                       .addReg(ARM::LR)
+                       .addReg(ARM::R12)
+                       .addImm(0)
+                       .add(predOps(Pred, PredReg))
+                       .setMIFlag(MachineInstr::ShadowStack));
+    } else {
+      // Generate an STR to the shadow stack
+      NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2STRs))
+                       .addReg(ARM::LR)
+                       .addReg(ARM::SP)
+                       .addReg(ARM::R12)
+                       .addImm(0)
+                       .add(predOps(Pred, PredReg))
+                       .setMIFlag(MachineInstr::ShadowStack));
+    }
+  }
+
+  // Now insert these new instructions into the basic block
+  insertInstsBefore(MI, NewMIs);
+}
+
+//
+// Method: popFromShadowStack()
+//
+// Description:
+//   This method modifies a POP instruction to not write to PC/LR and inserts
+//   new instructions that load the return address from the shadow stack into
+//   PC/LR.
+//
+// Input:
+//   MI   - A reference to a POP instruction after which to insert instructions.
+//   PCLR - A reference to the PC or LR operand of the POP.
+//
+void
+ARMSilhouetteShadowStack::popFromShadowStack(MachineInstr & MI,
+                                             MachineOperand & PCLR) {
+  MachineFunction & MF = *MI.getMF();
+  const TargetInstrInfo * TII = MF.getSubtarget().getInstrInfo();
+
+  int offset = ShadowStackOffset;
+
+  unsigned PredReg;
+  ARMCC::CondCodes Pred = getInstrPredicate(MI, PredReg);
+
+  std::deque<MachineInstr *> NewMIs;
+
+  // Adjust SP to skip PC/LR on the stack
+  NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::tADDspi), ARM::SP)
+                   .addReg(ARM::SP)
+                   .addImm(1)
+                   .add(predOps(Pred, PredReg))
+                   .setMIFlag(MachineInstr::ShadowStack));
+
+  if (offset >= 0 && offset <= 4092) {
+    // Single-instruction shortcut
+    NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2LDRi12), PCLR.getReg())
+                     .addReg(ARM::SP)
+                     .addImm(offset)
+                     .add(predOps(Pred, PredReg))
+                     .setMIFlag(MachineInstr::ShadowStack));
+  } else {
+    // First encode the shadow stack offset into the scratch register
+    if (ARM_AM::getT2SOImmVal(offset) != -1) {
+      // Use one MOV if the offset can be expressed in Thumb modified constant
+      NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2MOVi), ARM::R12)
+                       .addImm(offset)
+                       .add(predOps(Pred, PredReg))
+                       .add(condCodeOp()) // No 'S' bit
+                       .setMIFlag(MachineInstr::ShadowStack));
+    } else {
+      // Otherwise use MOV/MOVT to load lower/upper 16 bits of the offset
+      NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2MOVi16), ARM::R12)
+                       .addImm(offset & 0xffff)
+                       .add(predOps(Pred, PredReg))
+                       .setMIFlag(MachineInstr::ShadowStack));
+      if ((offset >> 16) != 0) {
+        NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2MOVTi16), ARM::R12)
+                         .addReg(ARM::R12)
+                         .addImm(offset >> 16)
+                         .add(predOps(Pred, PredReg))
+                         .setMIFlag(MachineInstr::ShadowStack));
+      }
+    }
+
+    // Generate an LDR from the shadow stack to PC/LR
+    NewMIs.push_back(BuildMI(MF, DL, TII->get(ARM::t2LDRs), PCLR.getReg())
+                     .addReg(ARM::SP)
+                     .addReg(ARM::R12)
+                     .addImm(0)
+                     .add(predOps(Pred, PredReg))
+                     .setMIFlag(MachineInstr::ShadowStack));
+  }
+
+  // Now insert these new instructions into the basic block
+  insertInstsAfter(MI, NewMIs);
+
+  // At last, replace the old POP with a new one that doesn't write to PC/LR
+  switch (MI.getOpcode()) {
+  case ARM::t2LDMIA_RET:
+    MI.setDesc(TII->get(ARM::t2LDMIA_UPD));
+    break;
+
+  case ARM::tPOP_RET:
+    MI.setDesc(TII->get(ARM::tPOP));
+    break;
+
+  default:
+    break;
+  }
+  MI.RemoveOperand(MI.getOperandNo(&PCLR));
+}
+
+//
+// Method: runOnMachineFunction()
+//
+// Description:
+//   This method is called when the PassManager wants this pass to transform
+//   the specified MachineFunction.  This method instruments the
+//   prologue/epilogue of a MachineFunction so that the return address is saved
+//   into/loaded from the shadow stack.
+//
+// Inputs:
+//   MF - A reference to the MachineFunction to transform.
+//
+// Outputs:
+//   MF - The transformed MachineFunction.
+//
+// Return value:
+//   true  - The MachineFunction was transformed.
+//   false - The MachineFunction was not transformed.
+//
+bool
+ARMSilhouetteShadowStack::runOnMachineFunction(MachineFunction & MF) {
+#if 1
+  // Skip certain functions
+  if (funcBlacklist.find(MF.getName()) != funcBlacklist.end()) {
+    return false;
+  }
+  // Skip privileged functions in FreeRTOS
+  if (MF.getFunction().getSection().equals("privileged_functions")){
+    errs() << "Privileged function! skipped\n";
+    return false;
+  }
+#endif
+
+  // Warn if the function has variable-sized objects; we assume the program is
+  // transformed by store-to-heap promotion, either via a compiler pass or
+  // manually
+  if (MF.getFrameInfo().hasVarSizedObjects()) {
+    errs() << "[SS] Variable-sized objects not promoted in "
+           << MF.getName() << "\n";
+  }
+
+  unsigned long OldCodeSize = getFunctionCodeSize(MF);
+
+  for (MachineBasicBlock & MBB : MF) {
+    for (MachineInstr & MI : MBB) {
+      switch (MI.getOpcode()) {
+      // Frame setup instructions in function prologue
+      case ARM::t2STMDB_UPD:
+        // STMDB_UPD writing to SP! is treated same as PUSH
+        if (MI.getOperand(0).getReg() != ARM::SP) {
+          break;
+        }
+        LLVM_FALLTHROUGH;
+      case ARM::tPUSH:
+        // LR can appear as a GPR not in prologue, in which case we don't care
+        if (MI.getFlag(MachineInstr::FrameSetup)) {
+          for (MachineOperand & MO : MI.operands()) {
+            if (MO.isReg() && MO.getReg() == ARM::LR) {
+              setupShadowStack(MI);
+              break;
+            }
+          }
+        }
+        break;
+
+      // Frame destroy instructions in function epilogue
+      case ARM::t2LDMIA_UPD:
+      case ARM::t2LDMIA_RET:
+        // LDMIA_UPD writing to SP! is treated same as POP
+        if (MI.getOperand(0).getReg() != ARM::SP) {
+          break;
+        }
+        LLVM_FALLTHROUGH;
+      case ARM::tPOP:
+      case ARM::tPOP_RET:
+        // Handle 2 cases:
+        // (1) POP writing to LR followed by TAILJMP.
+        // (2) POP writing to PC
+        for (MachineOperand & MO : MI.operands()) {
+          if (MO.isReg()) {
+            if ((MO.getReg() == ARM::LR && findTailJmp(MI) != nullptr) ||
+                MO.getReg() == ARM::PC) {
+              popFromShadowStack(MI, MO);
+              // Bail out as POP cannot write to both LR and PC
+              break;
+            }
+          }
+        }
+        break;
+
+      default:
+        break;
+      }
+    }
+  }
+
+  unsigned long NewCodeSize = getFunctionCodeSize(MF);
+
+  // Output code size information
+  std::error_code EC;
+  raw_fd_ostream MemStat("./code_size_ss.stat", EC,
+                         sys::fs::OpenFlags::F_Append);
+  MemStat << MF.getName() << ":" << OldCodeSize << ":" << NewCodeSize << "\n";
+
+  return true;
+}
+
+//
+// Create a new pass.
+//
+namespace llvm {
+  FunctionPass * createARMSilhouetteShadowStack(void) {
+    return new ARMSilhouetteShadowStack();
+  }
+}
diff --git a/llvm/lib/Target/ARM/ARMSilhouetteShadowStack.h b/llvm/lib/Target/ARM/ARMSilhouetteShadowStack.h
new file mode 100644
index 00000000000..a072c930049
--- /dev/null
+++ b/llvm/lib/Target/ARM/ARMSilhouetteShadowStack.h
@@ -0,0 +1,38 @@
+//===- ARMSilhouetteShadowStack - Modify Prologue/Epilogue for Shadow Stack ==//
+//
+//         Protecting Control Flow of Real-time OS applications
+//
+// This file was written by at the University of Rochester.
+// All Rights Reserved.
+//
+//===----------------------------------------------------------------------===//
+//
+// This pass instruments the function prologue/epilogue to save/load the return
+// address from a parallel shadow stack.
+//
+//===----------------------------------------------------------------------===//
+//
+
+#include "ARMSilhouetteInstrumentor.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+
+namespace llvm {
+
+  struct ARMSilhouetteShadowStack
+      : public MachineFunctionPass, ARMSilhouetteInstrumentor {
+    // pass identifier variable
+    static char ID;
+
+    ARMSilhouetteShadowStack();
+
+    virtual StringRef getPassName() const override;
+
+    virtual bool runOnMachineFunction(MachineFunction & MF) override;
+
+  private:
+    void setupShadowStack(MachineInstr & MI);
+    void popFromShadowStack(MachineInstr & MI, MachineOperand & PCLR);
+  };
+
+  FunctionPass * createARMSilhouetteShadowStack(void);
+}
diff --git a/llvm/lib/Target/ARM/ARMSubtarget.h b/llvm/lib/Target/ARM/ARMSubtarget.h
index c2b0f052b84..66f59fa751a 100644
--- a/llvm/lib/Target/ARM/ARMSubtarget.h
+++ b/llvm/lib/Target/ARM/ARMSubtarget.h
@@ -803,6 +803,8 @@ public:
   // enableAtomicExpand- True if we need to expand our atomics.
   bool enableAtomicExpand() const override;
 
+  bool enableIndirectBrExpand() const override { return true; }
+
   /// getInstrItins - Return the instruction itineraries based on subtarget
   /// selection.
   const InstrItineraryData *getInstrItineraryData() const override {
diff --git a/llvm/lib/Target/ARM/ARMTargetMachine.cpp b/llvm/lib/Target/ARM/ARMTargetMachine.cpp
index 7f0aae1739b..84a8224dd0a 100644
--- a/llvm/lib/Target/ARM/ARMTargetMachine.cpp
+++ b/llvm/lib/Target/ARM/ARMTargetMachine.cpp
@@ -15,6 +15,10 @@
 #include "ARMSubtarget.h"
 #include "ARMTargetObjectFile.h"
 #include "ARMTargetTransformInfo.h"
+#include "ARMSilhouetteLabelCFI.h"
+#include "ARMSilhouetteSFI.h"
+#include "ARMSilhouetteSTR2STRT.h"
+#include "ARMSilhouetteShadowStack.h"
 #include "MCTargetDesc/ARMMCTargetDesc.h"
 #include "TargetInfo/ARMTargetInfo.h"
 #include "llvm/ADT/Optional.h"
@@ -69,6 +73,52 @@ EnableARMLoadStoreOpt("arm-load-store-opt", cl::Hidden,
                       cl::desc("Enable ARM load/store optimization pass"),
                       cl::init(true));
 
+// Silhouette commandline options
+bool SilhouetteStr2Strt;
+static cl::opt<bool, true>
+EnableSilhouetteStr2Strt("enable-arm-silhouette-str2strt",
+                         cl::desc("Enable Silhouette store to unprivileged store pass"),
+                         cl::location(SilhouetteStr2Strt),
+                         cl::init(false), cl::Hidden);
+
+bool SilhouetteMemOverhead;
+static cl::opt<bool, true>
+EnableSilhouetteMemOverhead("enable-arm-silhouette-mem-overhead",
+                            cl::desc("Enable Silhouette memory overhead estimation pass"),
+                            cl::location(SilhouetteMemOverhead),
+                            cl::init(false), cl::Hidden);
+
+bool SilhouetteCFI;
+static cl::opt<bool, true>
+EnableSilhouetteCFI("enable-arm-silhouette-cfi",
+                    cl::desc("Enable Silhouette CFI pass"),
+                    cl::location(SilhouetteCFI),
+                    cl::init(false), cl::Hidden);
+
+bool SilhouetteShadowStack;
+static cl::opt<bool, true>
+EnableSilhouetteShadowStack("enable-arm-silhouette-shadowstack",
+                            cl::desc("Enable Silhouette shadow stack pass"),
+                            cl::location(SilhouetteShadowStack),
+                            cl::init(false), cl::Hidden);
+
+bool SilhouetteInvert;
+static cl::opt<bool, true>
+EnableSilhouetteInvert("enable-arm-silhouette-invert",
+                       cl::desc("Enable Silhouette Invert"),
+                       cl::location(SilhouetteInvert),
+                       cl::init(false), cl::Hidden);
+
+SilhouetteSFIOption SilhouetteSFI;
+static cl::opt<SilhouetteSFIOption, true>
+EnableSilhouetteSFI("enable-arm-silhouette-sfi",
+                    cl::desc("Enable Silhouette SFI"),
+                    cl::location(SilhouetteSFI),
+                    cl::init(NoSFI), cl::Hidden,
+                    cl::values(clEnumValN(NoSFI, "none", "No SFI"),
+                               clEnumValN(SelSFI, "selective", "Selective SFI"),
+                               clEnumValN(FullSFI, "full", "Full SFI")));
+
 // FIXME: Unify control over GlobalMerge.
 static cl::opt<cl::boolOrDefault>
 EnableGlobalMerge("arm-global-merge", cl::Hidden,
@@ -419,6 +469,10 @@ void ARMPassConfig::addIRPasses() {
   // Match interleaved memory accesses to ldN/stN intrinsics.
   if (TM->getOptLevel() != CodeGenOpt::None)
     addPass(createInterleavedAccessPass());
+
+  if (EnableSilhouetteCFI) {
+    addPass(createIndirectBrExpandPass());
+  }
 }
 
 void ARMPassConfig::addCodeGenPrepare() {
@@ -529,6 +583,25 @@ void ARMPassConfig::addPreEmitPass() {
   if (getOptLevel() != CodeGenOpt::None)
     addPass(createARMOptimizeBarriersPass());
 
-  addPass(createARMConstantIslandPass());
   addPass(createARMLowOverheadLoopsPass());
+
+  // Add Silhouette passes.
+
+  if (EnableSilhouetteShadowStack) {
+    addPass(createARMSilhouetteShadowStack());
+  }
+
+  if (EnableSilhouetteSFI != NoSFI) {
+    addPass(createARMSilhouetteSFI());
+  }
+
+  if (EnableSilhouetteStr2Strt) {
+    addPass(createARMSilhouetteSTR2STRT());
+  }
+
+  if (EnableSilhouetteCFI) {
+    addPass(createARMSilhouetteLabelCFI());
+  }
+
+  addPass(createARMConstantIslandPass());
 }
diff --git a/llvm/lib/Target/ARM/CMakeLists.txt b/llvm/lib/Target/ARM/CMakeLists.txt
index 586b6ea4535..12df78e8ea2 100644
--- a/llvm/lib/Target/ARM/CMakeLists.txt
+++ b/llvm/lib/Target/ARM/CMakeLists.txt
@@ -47,6 +47,11 @@ add_llvm_target(ARMCodeGen
   ARMOptimizeBarriersPass.cpp
   ARMRegisterBankInfo.cpp
   ARMSelectionDAGInfo.cpp
+  ARMSilhouetteInstrumentor.cpp
+  ARMSilhouetteLabelCFI.cpp
+  ARMSilhouetteSFI.cpp
+  ARMSilhouetteSTR2STRT.cpp
+  ARMSilhouetteShadowStack.cpp
   ARMSubtarget.cpp
   ARMTargetMachine.cpp
   ARMTargetObjectFile.cpp
diff --git a/llvm/lib/Transforms/Utils/InlineFunction.cpp b/llvm/lib/Transforms/Utils/InlineFunction.cpp
index a7f0f7ac5d6..dbb40ba1101 100644
--- a/llvm/lib/Transforms/Utils/InlineFunction.cpp
+++ b/llvm/lib/Transforms/Utils/InlineFunction.cpp
@@ -71,6 +71,8 @@
 #include <utility>
 #include <vector>
 
+#include "../../Target/ARM/ARMSilhouetteConvertFuncList.h"
+
 using namespace llvm;
 using ProfileCount = Function::ProfileCount;
 
@@ -1554,6 +1556,11 @@ llvm::InlineResult llvm::InlineFunction(CallSite CS, InlineFunctionInfo &IFI,
       CalledFunc->isDeclaration()) // call!
     return "external or indirect";
 
+  if (CalledFunc->hasName() &&
+      funcBlacklist.find(CalledFunc->getName()) != funcBlacklist.end()) {
+    return "blacklisted function";
+  }
+
   // The inliner does not know how to inline through calls with operand bundles
   // in general ...
   if (CS.hasOperandBundles()) {
